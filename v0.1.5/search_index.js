var documenterSearchIndex = {"docs":
[{"location":"man/examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples.html","page":"Examples","title":"Examples","text":"There are examples for every structure in the package within the package's examples/ folder. The code for several of these examples is provided here.","category":"page"},{"location":"man/examples.html#CVI","page":"Examples","title":"CVI","text":"","category":"section"},{"location":"man/examples.html#Xie-Beni-(XB)","page":"Examples","title":"Xie-Beni (XB)","text":"","category":"section"},{"location":"man/examples.html","page":"Examples","title":"Examples","text":"cvi = XB()","category":"page"},{"location":"man/contributing.html#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"man/contributing.html","page":"Contributing","title":"Contributing","text":"To formally contribute to the package, please follow the usual branch pull request procedure:","category":"page"},{"location":"man/contributing.html","page":"Contributing","title":"Contributing","text":"Fork the project.\nCreate your feature branch (git checkout -b my-new-feature).\nCommit your changes (git commit -am 'Added some feature').\nPush to the branch (git push origin my-new-feature).\nCreate a new GitHub pull request.","category":"page"},{"location":"man/contributing.html","page":"Contributing","title":"Contributing","text":"If you simply have suggestions for improvement, Sasha Petrenko (<sap625@mst.edu>) is the current developer and maintainer of the ClusterValidityIndices.jl package, so please feel free to reach out with thoughts and questions.","category":"page"},{"location":"man/guide.html#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"man/guide.html#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"The CVI package can be installed using the Julia package manager. From the Julia REPL, type ']' to enter the Pkg REPL mode and run","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"pkg> add CVI","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Alternatively, it can be added to your environment in a script with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"using Pkg\r\nPkg.add(\"CVI\")","category":"page"},{"location":"man/guide.html#Quickstart","page":"Guide","title":"Quickstart","text":"","category":"section"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"This section provides a quick overview of how to use the project. For more detailed code usage, please see Usage.","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"This project has several example scripts to demonstrate the functionality of CVIs in the ClusterValidityIndices.jl package. In ICVI-Examples/src/examples/, the scripts db.jl, ps.jl, and xb.jl demonstrate usage of the Davies-Boudin (DB), Partition Separation (PS), and Xie-Beni (XB) metrics, respectively.","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"note: Note\nEach of these scripts must be run at the top level of the project to correctly point to the datasets. For example, they can be run in the shell withjulia src/examples/db.jlor in a Julia REPL session withinclude(\"src/examples/db.jl\")","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Three preprocessed datasets are provided under data/ to demonstrate the correct partitioning, over partitioning, and under partitioning of samples by a clustering algorithm to illustrate how the CVIs behave in each case. The data consists of 2000 samples of 2-element features with the clustering label appended in the third column. You can change which dataset is used in each script above.","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Lastly, there is a large experiment script src/examples/combined.jl that runs every CVI with all three datasets. The common code for all scripts is contained under src/common.jl, while the experiment subroutines referenced in these scripts are under src/experiments.jl, so feel free to modify them to further explore the behavior and usage of these CVIs.","category":"page"},{"location":"man/guide.html#Usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"The usage of these CVIs requires an understanding of:","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Data assumptions of the CVIs.\nHow to instantiate the CVIs.\nIncremental vs. batch evaluation.\nUpdating internal CVI parameters.\nComputing and extracting the criterion values.\nPorcelain functions that are available to simplify operation.","category":"page"},{"location":"man/guide.html#data","page":"Guide","title":"Data","text":"","category":"section"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Because Julia is programmed in a column-major fashion, all CVIs make the assumption that the first dimension (columns) contains features, while the second dimension (rows) contains samples. This is more important for batch operation, as incremental operation accepts 1-D sample of features at each time step by definition.","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"For example,","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"# Load data from somewhere\r\ndata = load_data()\r\n# The data shape is dimsion x samples\r\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"note: Note\nAs of ClusterValidityIndices.jl v0.1.3, all the CVIs assume that the labels are presented sequentially initially, starting with index 1 (e.g., 1, 1, 2, 2, 3, 2, 2, 1, 3, 4, 4 ...). You may repeat previously seen label indices, but skipping label indices (e.g., 1, 2, 4) results in undefined behavior.","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"In this project, this is ameliorated with the function","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"relabel_cvi_data(labels::Array{M, 1}) where {M<:Int}","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"For example,","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"data_file = \"path/to/data.csv\"\r\ndata, labels = get_cvi_data(data_file)\r\nlabels = relabel_cvi_data(labels)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Alternatively, you may pairwise sort the entirety of the data with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"sort_cvi_data(data::Array{N, 2}, labels::Array{M, 1}) where {N<:Real, M<:Int}","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"note: Note\nsort_cvi_data reorders the input data as well, which will lead to different ICVI results than with relabel_cvi_data.","category":"page"},{"location":"man/guide.html#instantiation","page":"Guide","title":"Instantiation","text":"","category":"section"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"The names of each CVI are capital abbreviations of their literature names, often based upon the surname of the principal authors of the papers that introduce the metrics. All CVIs are implemented with the default constructor, such as","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"cvi = DB()","category":"page"},{"location":"man/guide.html#inc-batch","page":"Guide","title":"Incremental vs. Batch","text":"","category":"section"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"The CVIs in this project all contain incremental and batch implementations. When evaluated in incremental mode, they are often called ICVIs (incremental cluster validity indices). In documentation, CVI refers to both modalities (as in the literature), but in code, CVI means batch and ICVI means incremental.","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"The funtions that differ between the two modes are how they are updated","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"# Incremental\r\nparam_inc!(...)\r\n# Batch\r\nparam_batch!(...)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"and their respective porcelain functions","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"# Incremental\r\nget_icvi!(...)\r\n# Batch\r\nget_cvi!(...)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"They both compute their most recent criterion values with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"evaluate!(...)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"note: Note\nAny CVI can switch to be updated incrementally or in batch, as the CVI data structs are update mode agnostic.","category":"page"},{"location":"man/guide.html#updating","page":"Guide","title":"Updating","text":"","category":"section"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"The CVIs in this project all contain internal parameters that must be updated. Each update function modifies the CVI, so they use the Julia nomenclature convention of appending an exclamation point to indicate as much.","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"In both incremental and batch modes, the parameter update requires:","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"The CVI being updates\nThe sample (or array of samples)\nThe label(s) that was/were prescribed by the clustering algorithm to the sample(s)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"More concretely, they are","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"# Incremental updating\r\nparam_inc!(cvi::C, sample::Array{T, 1}, label::I) where {C<:AbstractCVI, T<:Real, I<:Int}\r\n# Batch updating\r\nparam_batch!(cvi::C, data::Array{T, 2}, labels::Array{I, 1}) where {C<:AbstractCVI, T<:Real, I<:Int}","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Every CVI is a subtype of the abstract type AbstractCVI. For example, we may instantiate and load our data","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"cvi = DB()\r\ndata = load_data()\r\nlabels = get_cluster_labels(data)\r\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"then update the parameters incrementally with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"# Iterate over all samples\r\nfor ix = 1:n_samples\r\n    sample = data[:, ix]\r\n    label = labels[ix]\r\n    param_inc!(cvi, sample, labels)\r\nend","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"or in batch with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"param_batch!(cvi, data, labels)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Furthermore, any CVI can alternate between being updated in incremental or batch modes, such as","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"# Create a new CVI\r\ncvi_mixed = DB()\r\n\r\n# Update on half of the data incrementally\r\ni_split = n_samples/2\r\nfor ix = 1:i_split\r\n    param_inc!(cvi, data[:, ix], labels[ix])\r\nend\r\n\r\n# Update on the other half all at once\r\nparam_batch!(cvi, data[:, (i_split+1):end])","category":"page"},{"location":"man/guide.html#criterion-values","page":"Guide","title":"Criterion Values","text":"","category":"section"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"The CVI parameters are separate from the criterion values that they produce. This is partly because in batch mode computing the criterion value is only relevant at the last step, which eliminates unnecessarily computing it at every step. This is also provide granularity to the user that may only which to extract the criterion value occasionally during incremental mode.","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Because the criterion values only depend on the internal CVI parameters, they are computed (and internally stored) with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"evaluate!(cvi::C) where {C<:AbstractCVI}","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"To extract them, you must then simply grab the criterion value from the CVI struct with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"criterion_value = cvi.criterion_value","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"For example, after loading the data","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"cvi = DB()\r\ndata = load_data()\r\nlabels = get_cluster_labels(data)\r\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"we may extract and return the criterion value at every step with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"criterion_values = zeros(n_samples)\r\nfor ix = 1:n_samples\r\n    param_inc!(cvi, data[:, ix], labels[ix])\r\n    evaluate!(cvi)\r\n    criterion_values[ix] = cvi.criterion_value\r\nend","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"or we may get it at the end in batch mode with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"param_batch!(cvi, data, labels)\r\nevaluate!(cvi)\r\ncriterion_value = cvi.criterion_value","category":"page"},{"location":"man/guide.html#porcelain","page":"Guide","title":"Porcelain","text":"","category":"section"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Taken from the git convention of calling low-level operations plumbing and high-level user-land functions porcelain, the package comes with a small set of porcelain function that do common operations all at once for the user.","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"For example, you may compute, evalute, and return the criterion value all at once with the functions","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"# Incremental\r\nget_icvi!(...)\r\n# Batch\r\nget_cvi!(...)","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"Exactly as in the usage for updating the parameters, the functions take the cvi, sample(s), and clustered label(s) as input:","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"# Incremental\r\nget_icvi!(cvi::C, x::Array{N, 1}, y::M) where {C<:AbstractCVI, N<:Real, M<:Int}\r\n# Batch\r\nget_cvi!(cvi::C, x::Array{N, 2}, y::Array{M, 1}) where {C<:AbstractCVI, N<:Real, M<:Int}","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"For example, after loading the data you may get the criterion value at each step with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"criterion_values = zeros(n_samples)\r\nfor ix = 1:n_samples\r\n    criterion_values[ix] = get_icvi!(cvi, data[:, ix], labels[ix])\r\nend","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"or you may get the final criterion value in batch mode with","category":"page"},{"location":"man/guide.html","page":"Guide","title":"Guide","text":"criterion_value = get_cvi!(cvi, data, labels)","category":"page"},{"location":"index.html#ClusterValidityIndices.jl","page":"Home","title":"ClusterValidityIndices.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"These pages serve as the official documentation for the ClusterValidityIndices.jl Julia package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Cluster Validity Indices (CVI) tackle the problem of judging the performance of an unsupervised/clustering algorithm without the availability of truth or supervisory labels, resulting in metrics of under- or over-partitioning. Furthermore, Incremental CVIs (ICVI) are variants of these ordinarily batch algorithms that enable an online and computationally tractable method of evaluating the performance of a clustering algorithm as it clusters while being numerically equivalent to their batch counterparts.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The purpose of this package is to provide a home for the development and use of these CVIs and ICVIs.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"index.html#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This documentation is split into the following sections:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\r\n    \"man/guide.md\",\r\n    \"man/examples.md\",\r\n    \"man/contributing.md\",\r\n    \"man/full-index.md\",\r\n]\r\nDepth = 1","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The Package Guide provides a tutorial to the full usage of the package, while Examples gives sample workflows using a variety of ART modules.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Instructions on how to contribute to the package are found in Contributing, and docstrings for every element of the package is listed in the Index.","category":"page"},{"location":"man/full-index.html#main-index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/full-index.html","page":"Index","title":"Index","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"man/full-index.html","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]","category":"page"},{"location":"man/full-index.html#ClusterValidityIndices.CH","page":"Index","title":"ClusterValidityIndices.CH","text":"CH\n\nThe stateful information of the Calinski-Harabasz (CH) Cluster Validity Index\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nT. Calinski and J. Harabasz, \"A dendrite method for cluster analysis,\" Communications in Statistics, vol. 3, no. 1, pp. 1–27, 1974.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index.html#ClusterValidityIndices.CH-Tuple{}","page":"Index","title":"ClusterValidityIndices.CH","text":"CH()\n\nDefault constructor for the Calinski-Harabasz (CH) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.DB","page":"Index","title":"ClusterValidityIndices.DB","text":"DB\n\nThe stateful information of the Davies-Bouldin (DB) Cluster Validity Index.\n\nReferences\n\nD. L. Davies and D. W. Bouldin, \"A cluster separation measure,\" IEEE Transaction on Pattern Analysis and Machine Intelligence, vol. 1, no. 2, pp. 224–227, Feb. 1979.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index.html#ClusterValidityIndices.DB-Tuple{}","page":"Index","title":"ClusterValidityIndices.DB","text":"DB()\n\nDefault constructor for the Davies-Bouldin (DB) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.GD43","page":"Index","title":"ClusterValidityIndices.GD43","text":"GD43\n\nThe stateful information of the Generalized Dunn's Index 43 (GD43) Cluster Validity Index.\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1–12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32–57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301–315, Jun. 1998.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index.html#ClusterValidityIndices.GD43-Tuple{}","page":"Index","title":"ClusterValidityIndices.GD43","text":"GD43()\n\nDefault constructor for the Generalized Dunn's Index 43 (GD43) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.GD53","page":"Index","title":"ClusterValidityIndices.GD53","text":"GD53\n\nThe stateful information of the Generalized Dunn's Index 53 (GD53) Cluster Validity Index.\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1–12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32–57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301–315, Jun. 1998.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index.html#ClusterValidityIndices.GD53-Tuple{}","page":"Index","title":"ClusterValidityIndices.GD53","text":"GD53()\n\nDefault constructor for the Generalized Dunn's Index 53 (GD53) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.PS","page":"Index","title":"ClusterValidityIndices.PS","text":"PS\n\nThe stateful information of the Partition Separation (PS) Cluster Validity Index.\n\nReferences\n\nMiin-Shen Yang and Kuo-Lung Wu, \"A new validity index for fuzzy clustering,\" 10th IEEE International Conference on Fuzzy Systems. (Cat. No.01CH37297), Melbourne, Victoria, Australia, 2001, pp. 89-92, vol.1.\nE. Lughofer, \"Extensions of vector quantization for incremental clustering,\" Pattern Recognit., vol. 41, no. 3, pp. 995–1011, 2008.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index.html#ClusterValidityIndices.PS-Tuple{}","page":"Index","title":"ClusterValidityIndices.PS","text":"PS()\n\nDefault constructor for the Partition Separation (PS) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.WB","page":"Index","title":"ClusterValidityIndices.WB","text":"WB\n\nThe stateful information of the WB-Index (WB) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nQ. Zhao, M. Xu, and P. Franti, \"Sum-of-Squares Based Cluster Validity Index and Significance Analysis,\" in Adaptive and Natural Computing Algorithms, M. Kolehmainen, P. Toivanen, and B. Beliczynski, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009, pp. 313–322.\nQ. Zhao and P. Franti, \"WB-index: A sum-of-squares based index for cluster validity,\" Data Knowledge Engineering, vol. 92, pp. 77–89, 2014.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index.html#ClusterValidityIndices.WB-Tuple{}","page":"Index","title":"ClusterValidityIndices.WB","text":"WB()\n\nDefault constructor for the WB-Index (WB) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.XB","page":"Index","title":"ClusterValidityIndices.XB","text":"XB\n\nThe stateful information of the Xie-Beni (XB) Cluster Validity Index.\n\nReferences\n\nX. L. Xie and G. Beni, \"A Validity Measure for Fuzzy Clustering,\" IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 13, no. 8, pp. 841–847, 1991.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index.html#ClusterValidityIndices.XB-Tuple{}","page":"Index","title":"ClusterValidityIndices.XB","text":"XB()\n\nDefault constructor for the Xie-Beni (XB) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.cSIL","page":"Index","title":"ClusterValidityIndices.cSIL","text":"cSIL\n\nThe stateful information of the Centroid-based Silhouette (cSIL) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nP. J. Rousseeuw, \"Silhouettes: A graphical aid to the interpretation and validation of cluster analysis,\" Journal of Computational and Applied Mathematics, vol. 20, pp. 53–65, 1987.\nM. Rawashdeh and A. Ralescu, \"Center-wise intra-inter silhouettes,\" in Scalable Uncertainty Management, E. Hüllermeier, S. Link, T. Fober et al., Eds. Berlin, Heidelberg: Springer, 2012, pp. 406–419.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index.html#ClusterValidityIndices.cSIL-Tuple{}","page":"Index","title":"ClusterValidityIndices.cSIL","text":"cSIL()\n\nDefault constructor for the Centroid-based Silhouette (cSIL) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.rCIP","page":"Index","title":"ClusterValidityIndices.rCIP","text":"rCIP\n\nThe stateful information of the (Renyi's) representative Cross Information Potential (rCIP) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nE. Gokcay and J. C. Principe, \"A new clustering evaluation function using Renyi’s information potential,\" in Proc. Int. Conf. Acoust., Speech, Signal Process. (ICASSP), vol. 6. Jun. 2000, pp. 3490–3493.\nE. Gokcay and J. C. Principe, \"Information theoretic clustering,\" IEEE Trans. Pattern Anal. Mach. Intell., vol. 24, no. 2, pp. 158–171, Feb. 2002.\nD. Araújo, A. D. Neto, and A. Martins, \"Representative cross information potential clustering,\" Pattern Recognit. Lett., vol. 34, no. 16, pp. 2181–2191, Dec. 2013.\nD. Araújo, A. D. Neto, and A. Martins, \"Information-theoretic clustering: A representative and evolutionary approach,\" Expert Syst. Appl., vol. 40, no. 10, pp. 4190–4205, Aug. 2013.\nR. O. Duda, P. E. Hart, and D. G. Stork, Pattern Classification, 2nd ed. John Wiley & Sons, 2000.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index.html#ClusterValidityIndices.rCIP-Tuple{}","page":"Index","title":"ClusterValidityIndices.rCIP","text":"rCIP()\n\nDefault constructor for the (Renyi's) representative Cross Information Potential (rCIP) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.evaluate!-Tuple{CVI}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::CVI)\n\nCompute the criterion value of the CVI.\n\nAfter computation, the resulting criterion value can be extracted from cvi.criterion_value. The criterion value is a function of the CVI/ICVI internal parameters, so at least two classes (i.e., unique labels) must be presented to the CVI in param_inc! or param_batch! before a non-zero value is returned.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI to use for computing the criterion value.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_batch!(my_cvi, data, labels)\njulia> evaluate!(my_cvi)\njulia> my_criterion_value = my_cvi.criterion_value\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.get_cvi!-Tuple{CVI, AbstractMatrix{T} where T<:Real, AbstractVector{T} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.get_cvi!","text":"get_cvi!(cvi::CVI, data::RealMatrix, labels::IntegerVector)\n\nCompute and return the criterion value in batch mode.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI providing the criterion value.\ndata::RealMatrix: a matrix of data, columns as samples and rows as features, used in the external clustering process.\nlabels::IntegerVector: a vector of integers representing labels prescribed to the data by the external clustering algorithm.\n\nExamples\n\n# Create a new CVI object\nmy_cvi = CH()\n# Load in data from some external source\ndata = load_some_data()\n# Cluster the data into a set of labels as an integer vector\nlabels = my_cluster_algorithm(data)\n# Compute the final criterion value in batch mode\ncriterion_value = get_cvi!(cvi, data, labels)\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.get_icvi!-Tuple{CVI, AbstractVector{T} where T<:Real, Integer}","page":"Index","title":"ClusterValidityIndices.get_icvi!","text":"get_icvi!(cvi::CVI, sample::RealVector, label::Integer)\n\nCompute and return the criterion value incrementally.\n\nArguments\n\ncvi::CVI: the stateful information of the ICVI providing the criterion value.\nsample::RealVector: the sample provided to the external. clustering algorithm.\nlabel::Integer: the label prescribed to the sample by the external clustering algorithm.\n\nExamples\n\n# Create a new CVI object\nmy_cvi = CH()\n# Load in data from some external source\ndata = load_some_data()\n# Cluster the data into a set of labels as an integer vector\nlabels = my_cluster_algorithm(data)\n# Iteratively compute and extract the criterion value at every step\nn_samples = length(labels)\ncriterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    sample = data[:, ix]\n    label = labels[ix]\n    criterion_values[ix] = get_icvi!(my_cvi, sample, label)\nend\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.get_internal_label!-Tuple{Dict{Int64, Int64}, Int64}","page":"Index","title":"ClusterValidityIndices.get_internal_label!","text":"get_internal_label!(label_map::LabelMap, label::Int)\n\nGet the internal label and update the label map if the label is new.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.param_batch!-Tuple{CVI, AbstractMatrix{T} where T<:Real, AbstractVector{T} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::CVI, data::RealMatrix, labels::IntegerVector)\n\nCompute the CVI parameters in batch.\n\nThis method updates only the internal parameters of the CVI algorithm in batch. When the criterion value itself is needed, use evaluate! and extract it from cvi.criterion_value.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI algorithm.\ndata::RealMatrix: a matrix of data where rows are features and columns are samples, used in the external clustering algorithm.\nlabels::IntegerVector: a vector of labels that the external clustering algorithm prescribed to each column in data.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_batch!(my_cvi, data, labels)\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.param_inc!-Tuple{CVI, AbstractVector{T} where T<:Real, Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::CVI, sample::RealVector, label::Integer)\n\nCompute the CVI parameters incrementally.\n\nThis method updates only internal parameters of the ICVI algorithm incrementally. When the criterion value itself is needed, use evaluate! and extract it from cvi.criterion_value.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI algorithm.\nsample::RealVector: a vector of features used in the external clustering algorithm.\nlabel::Integer: the label that the external clustering algorithm prescribed to the sample.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_inc!(my_cvi, data[:, 1], labels[1])\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.relabel_cvi_data-Tuple{AbstractVector{T} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.relabel_cvi_data","text":"relabel_cvi_data(labels::IntegerVector)\n\nRelabels the vector to present new labels in incremental order.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{CH, Vector{T}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::CH, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{DB, Vector{T}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::DB, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{GD43, Vector{T}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::GD43, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{GD53, Vector{T}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::GD53, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{PS, Vector{T}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::PS, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{WB, Vector{T}}} where T<:Real","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::WB, sample::Vector{T}) where {T<:Real}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{XB, Vector{T}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::XB, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{cSIL, Vector{T}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::cSIL, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{rCIP, Vector{T}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::rCIP, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index.html#ClusterValidityIndices.sort_cvi_data-Tuple{AbstractMatrix{T} where T<:Real, AbstractVector{T} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.sort_cvi_data","text":"sort_cvi_data(data::RealMatrix, labels::IntegerVector)\n\nSorts the CVI data by the label index, assuring that clusters are provided incrementally.\n\n\n\n\n\n","category":"method"}]
}
