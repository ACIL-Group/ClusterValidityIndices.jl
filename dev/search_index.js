var documenterSearchIndex = {"docs":
[{"location":"examples/basic-examples/cvi-example/#cvi_example","page":"CVI Simple Example","title":"CVI Simple Example","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/basic-examples/cvi-example/#Overview","page":"CVI Simple Example","title":"Overview","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"This demo is a simple example of how to use CVIs in batch mode. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. It is a combination of these features and the prescribed labels that are used to compute the criterion value. This simple example demonstrates the usage of a single CVI, but it may be substituted for any other CVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/basic-examples/cvi-example/#Clustering","page":"CVI Simple Example","title":"Clustering","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/#Data-Setup","page":"CVI Simple Example","title":"Data Setup","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"using ClusterValidityIndices    # CVI/ICVI\nusing Clustering                # DBSCAN\nusing MLDatasets                # Iris dataset\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Iris.download(i_accept_the_terms_of_use=true)\nfeatures, labels = Iris.features(), Iris.labels()","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"labels = convertlabel(LabelEnc.Indices{Int}, labels)\nunique(labels)","category":"page"},{"location":"examples/basic-examples/cvi-example/#Fuzzy-C-Means","page":"CVI Simple Example","title":"Fuzzy C-Means","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Get the Fuzzy C-Means clustering result","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"results = fuzzy_cmeans(features, 3, 2)","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Because the results are fuzzy weights, find the maximum elements along each sample","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"indices = argmax(results.weights, dims=2)","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Get those labels as a vector of integers","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"c_labels = vec([c[2] for c in indices])","category":"page"},{"location":"examples/basic-examples/cvi-example/#CVI-Criterion-Value-Extraction","page":"CVI Simple Example","title":"CVI Criterion Value Extraction","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Now that we have some data and a clustering algorithm's prescribed labels, we can compute a criterion value using a CVI in batch mode. First, we create a CVI object with the default constructor:","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"# Create a CVI object\nmy_cvi = CH()","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Finally we can simply get the criterion value in batch by passing all of the data and Fuzzy C-Means labels at once.","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"# Get the batch criterion value\ncriterion_value = get_cvi!(my_cvi, features, c_labels)","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/cvis/cvi-icvi/#cvi_icvi","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/cvis/cvi-icvi/#Overview","page":"CVI-ICVI Comparison","title":"Overview","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"This demo is a simple example of how to use CVIs incrementally and in batch to demonstrate that the end results are the same. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. In the incremental case, we will take advantage of the fact that we can compute a criterion value at every step by running the ICVI alongside an online clustering algorithm. This simple example demonstrates the usage of a single CVI/ICVI, but it may be substituted for any other CVI/ICVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/cvis/cvi-icvi/#Data-Setup","page":"CVI-ICVI Comparison","title":"Data Setup","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing\nusing Plots","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Iris.download(i_accept_the_terms_of_use=true)\nfeatures, labels = Iris.features(), Iris.labels()","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"labels = convertlabel(LabelEnc.Indices{Int}, labels)\nunique(labels)","category":"page"},{"location":"examples/cvis/cvi-icvi/#CVI/ICVI-Setup","page":"CVI-ICVI Comparison","title":"CVI/ICVI Setup","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Because CVI/ICVIs only differ in their evaluation mode, we will use the same default constructor for both of our objects. Here, we will use the same type of CVI for both objects to verify that the results of both are the same at the final iteration.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Create both CVI objects, using one incrementally as an ICVI\nicvi = CH()\ncvi = CH()","category":"page"},{"location":"examples/cvis/cvi-icvi/#Online-Clustering","page":"CVI-ICVI Comparison","title":"Online Clustering","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/#Adaptive-Resonance-Theory-Algorithms","page":"CVI-ICVI Comparison","title":"Adaptive Resonance Theory Algorithms","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Create a Distributed Dual-Vigilance Fuzzy ART (DDVFA) module with default options\nart = DDVFA()\ntypeof(art)","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Because we are streaming clustering, we must setup the internal data setup of the DDVFA module. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Setup the data configuration for the module\ndata_setup!(art.config, features)\n# Verify that the data is setup\nart.config.setup","category":"page"},{"location":"examples/cvis/cvi-icvi/#Iteration","page":"CVI-ICVI Comparison","title":"Iteration","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"We can now cluster and get the criterion values online We will do this by creating an ICVI object, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Setup the online/streaming clustering\nn_samples = length(labels)          # Number of samples\nc_labels = zeros(Int, n_samples)    # Clustering labels\ncriterion_values = zeros(n_samples) # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Cluster the sample online\n    c_labels[ix] = train!(art, sample)\n    # Get the new criterion value (ICVI output)\n    criterion_values[ix] = get_icvi!(icvi, sample, c_labels[ix])\nend\n\n# See the list of criterion values\ncriterion_values","category":"page"},{"location":"examples/cvis/cvi-icvi/#Batch-Evaluation","page":"CVI-ICVI Comparison","title":"Batch Evaluation","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"In batch mode, we will use the sample features and prescribed cluster labels as before to verify that the criterion values are the same at the last iteration.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Get the final criterion value in batch\nbatch_criterion_value = get_cvi!(cvi, features, c_labels)","category":"page"},{"location":"examples/cvis/cvi-icvi/#Comparison","page":"CVI-ICVI Comparison","title":"Comparison","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Now we check that the two produce the same results in the end.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Print the batch result and the final result of the incremental variant\n@printf \"Batch criterion value: %.4f\\n\" batch_criterion_value\n@printf \"Final incremental criterion value: %.4f\\n\" criterion_values[end]","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/basic-examples/icvi-example/#icvi_example","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/basic-examples/icvi-example/#Overview","page":"ICVI Simple Example","title":"Overview","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"This demo is a simple example of how to use CVIs incrementally. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. We will take advantage of the fact that we can compute a criterion value at every step by running the ICVI alongside an online clustering algorithm. This simple example demonstrates the usage of a single ICVI, but it may be substituted for any other ICVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/basic-examples/icvi-example/#Online-Clustering","page":"ICVI Simple Example","title":"Online Clustering","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/#Data-Setup","page":"ICVI Simple Example","title":"Data Setup","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing\nusing Plots","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"Iris.download(i_accept_the_terms_of_use=true)\nfeatures, labels = Iris.features(), Iris.labels()","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"labels = convertlabel(LabelEnc.Indices{Int}, labels)\nunique(labels)","category":"page"},{"location":"examples/basic-examples/icvi-example/#ART-Online-Clustering","page":"ICVI Simple Example","title":"ART Online Clustering","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"# Create a Distributed Dual-Vigilance Fuzzy ART (DDVFA) module with default options\nart = DDVFA()\ntypeof(art)","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"Because we are streaming clustering, we must setup the internal data setup of the DDVFA module. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"# Setup the data configuration for the module\ndata_setup!(art.config, features)\n# Verify that the data is setup\nart.config.setup","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"We can now cluster and get the criterion values online. We will do this by creating an ICVI object, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"# Create an ICVI object\nicvi = CH()\n\n# Setup the online/streaming clustering\nn_samples = length(labels)          # Number of samples\nc_labels = zeros(Int, n_samples)    # Clustering labels\ncriterion_values = zeros(n_samples) # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Cluster the sample online\n    c_labels[ix] = train!(art, sample)\n    # Get the new criterion value (ICVI output)\n    criterion_values[ix] = get_icvi!(icvi, sample, c_labels[ix])\nend\n\n# See the list of criterion values\ncriterion_values","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/cvis/icvi-comparison/#icvi_comparison","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/cvis/icvi-comparison/#Overview","page":"Multi-ICVI Comparisons","title":"Overview","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"This demo demostrates the differing behavior of the various ICVIs implemented in ClusterValidityIndices.jl. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. We will take advantage of the fact that we can compute a criterion value at every step by running the ICVI alongside an online clustering algorithm.","category":"page"},{"location":"examples/cvis/icvi-comparison/#Online-Clustering","page":"Multi-ICVI Comparisons","title":"Online Clustering","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/#Data-Setup","page":"Multi-ICVI Comparisons","title":"Data Setup","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing\nusing Plots","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Iris.download(i_accept_the_terms_of_use=true)\nfeatures, labels = Iris.features(), Iris.labels()","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"labels = convertlabel(LabelEnc.Indices{Int}, labels)\nunique(labels)","category":"page"},{"location":"examples/cvis/icvi-comparison/#ART-Online-Clustering","page":"Multi-ICVI Comparisons","title":"ART Online Clustering","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Create a Distributed Dual-Vigilance Fuzzy ART (DDVFA) module with default options\nart = DDVFA()\ntypeof(art)","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Because we are streaming clustering, we must setup the internal data setup of the DDVFA module. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Setup the data configuration for the module\ndata_setup!(art.config, features)\n# Verify that the data is setup\nart.config.setup","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We can now cluster and get the criterion values online. We will do this by creating many ICVI objects, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Create many ICVI objects\nicvis = [\n    CH(),\n    cSIL(),\n    DB(),\n    GD43(),\n    GD53(),\n    PS(),\n    rCIP(),\n    WB(),\n    XB(),\n]\n\n# Setup the online/streaming clustering\nn_samples = length(labels)          # Number of samples\nn_icvi = length(icvis)              # Number of ICVIs being computed\nc_labels = zeros(Int, n_samples)    # Clustering labels\ncriterion_values = zeros(n_icvi, n_samples) # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Cluster the sample online\n    c_labels[ix] = train!(art, sample)\n    # Get the new criterion values (ICVI output)\n    for jx = 1:n_icvi\n        criterion_values[jx, ix] = get_icvi!(icvis[jx], sample, c_labels[ix])\n    end\nend\n\n# See the matrix of criterion values\ncriterion_values","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We can inspect the final ICVI values to see how they differ:","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"criterion_values[:, end]","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"man/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"This page serves as the contribution guide for the ClusterValidityIndices.jl package. From top to bottom, the ways of contributing are:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"GitHub Issues: how to raise an issue with the project.\nJulia Development: how to download and interact with the package.\nGitFlow: how to directly contribute code to the package in an organized way on GitHub.\nDevelopment Details: how the internals of the package are currently setup if you would like to directly contribute code.","category":"page"},{"location":"man/contributing/#Issues","page":"Contributing","title":"Issues","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The main point of contact is the GitHub issues page for the project. This is the easiest way to contribute to the project, as any issue you find or request you have will be addressed there by the authors of the package. Depending on the issue, the authors will collaborate with you, and after making changes they will link a pull request which addresses your concern or implements your proposed changes.","category":"page"},{"location":"man/contributing/#Julia-Development","page":"Contributing","title":"Julia Development","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"As a Julia package, development follows the usual procedure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Clone the project from GitHub\nSwitch to or create the branch that you wish work on (see GitFlow).\nStart Julia at your development folder.\nInstantiate the package (i.e., download and install the package dependencies).","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"For example, you can get the package and startup Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"git clone git@github.com:AP6YC/ClusterValidityIndices.jl.git\njulia --project=.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIn Julia, you must activate your project in the current REPL to point to the location/scope of installed packages. The above immediately activates the project when starting up Julia, but you may also separately startup the julia and activate the package with the interactive package manager via the ] syntax:julia\njulia> ]\n(@v1.6) pkg> activate .\n(ClusterValidityIndices) pkg>","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"You may run the package's unit tests after the above setup in Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> using Pkg\njulia> Pkg.instantiate()\njulia> Pkg.test()","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"or interactively though the Julia package manager with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> ]\n(ClusterValidityIndices) pkg> instantiate\n(ClusterValidityIndices) pkg> test","category":"page"},{"location":"man/contributing/#GitFlow","page":"Contributing","title":"GitFlow","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"As of verson 0.3.1, the ClusterValidityIndices.jl package follows the GitFlow git working model. The original post by Vincent Driessen outlines this methodology quite well, while Atlassian has a good tutorial as well. In summary:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Create a feature branch off of the develop branch with the name feature/<my-feature-name>.\nCommit your changes and push to this feature branch.\nWhen you are satisfied with your changes, initiate a GitHub pull request (PR) to merge the feature branch with develop.\nIf the unit tests pass, the feature branch will first be merged with develop and then be deleted.\nReleases will be periodically initiated from the develop branch and versioned onto the master branch.\nImmediate bug fixes circumvent this process through a hotfix branch off of master.","category":"page"},{"location":"man/contributing/#Development-Details","page":"Contributing","title":"Development Details","text":"","category":"section"},{"location":"man/contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"These docs are currently hosted as a static site on the GitHub pages platform. They are setup to be built and served in a separate branch gh-pages from the master/development branch of the project.","category":"page"},{"location":"man/contributing/#Package-Structure","page":"Contributing","title":"Package Structure","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The ClusterValidityIndices.jl package has the following file structure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"ClusterValidityIndices.jl\n├── .github/workflows       // GitHub: workflows for testing and documentation.\n├── data                    // Data: CI and example data location.\n├── docs                    // Docs: GitHub pages documentation files.\n├── examples                // Source: Example scripts for CVI usage.\n├── paper                   // Docs: JOSS paper and bib files.\n├── results                 // Data: Destination for example-generated files.\n├── src                     // Source: scripts and common helper functions.\n│   └─── CVI                //      All CVI and ICVI definitions\n├── test                    // Test: unit, integration, and environment tests.\n├── .gitignore              // Git: .gitignore for the whole project.\n├── LICENSE                 // Doc: the license to the project.\n├── Manifest.toml           // Julia: the explicit package versions used.\n├── Project.toml            // Julia: the Pkg.jl dependencies of the project.\n└── README.md               // Doc: this document.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"All CVIs are implemented in separate files in the src/CVI/ directory, and they are imported to src/ClusterValidityIndices.jl through imports in src/CVI/CVI.jl.","category":"page"},{"location":"man/contributing/#CVI-Module-Workflow","page":"Contributing","title":"CVI Module Workflow","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"To write a CVI for this project, it will require the following:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"A struct subtyped from CVI that implements the internal parameters in addition to a Float named criterion_value and a LabelMap.\nA Default constructor that initializes values to zeros and arrays to empties (see existing CVI files such as DB.jl for examples).\nAn incremental parameter update method param_inc!(cvi::NEW_CVI, sample::RealVector, label::Integer) where NEW_CVI is the name of the new CVI.\nA batch parameter update method param_batch!(cvi::NEW_CVI, data::RealMatrix, labels::IntegerVector).\nA criterion value evaluation method evaluate(cvi::NEW_CVI) that updates the internal criterion value.","category":"page"},{"location":"man/contributing/#Authors","page":"Contributing","title":"Authors","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"If you simply have suggestions for improvement, Sasha Petrenko (<sap625@mst.edu>) is the current developer and maintainer of the ClusterValidityIndices.jl package, so please feel free to reach out with thoughts and questions.","category":"page"},{"location":"man/full-index/#main-index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This page lists the core methods and types of the ClusterValidityIndices.jl package. The Methods section lists the public methods for the package that use the CVIs/ICVIs in Types. Each of these entries link to the docstrings in the Docs section.","category":"page"},{"location":"man/full-index/#index-methods","page":"Index","title":"Methods","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]\nOrder = [:function]\nPublic = true","category":"page"},{"location":"man/full-index/#index-types","page":"Index","title":"Types","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]\nOrder = [:type]\nPublic = true","category":"page"},{"location":"man/full-index/#index-docs","page":"Index","title":"Docs","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"get_cvi!\nget_icvi!\nparam_inc!\nparam_batch!\nevaluate!\nCH\ncSIL\nDB\nGD43\nPS\nrCIP\nWB\nXB","category":"page"},{"location":"man/full-index/#ClusterValidityIndices.get_cvi!","page":"Index","title":"ClusterValidityIndices.get_cvi!","text":"get_cvi!(cvi::CVI, data::RealMatrix, labels::IntegerVector)\n\nCompute and return the criterion value in batch mode.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI providing the criterion value.\ndata::RealMatrix: a matrix of data, columns as samples and rows as features, used in the external clustering process.\nlabels::IntegerVector: a vector of integers representing labels prescribed to the data by the external clustering algorithm.\n\nExamples\n\n# Create a new CVI object\nmy_cvi = CH()\n# Load in data from some external source\ndata = load_some_data()\n# Cluster the data into a set of labels as an integer vector\nlabels = my_cluster_algorithm(data)\n# Compute the final criterion value in batch mode\ncriterion_value = get_cvi!(cvi, data, labels)\n\n\n\n\n\n","category":"function"},{"location":"man/full-index/#ClusterValidityIndices.get_icvi!","page":"Index","title":"ClusterValidityIndices.get_icvi!","text":"get_icvi!(cvi::CVI, sample::RealVector, label::Integer)\n\nCompute and return the criterion value incrementally.\n\nArguments\n\ncvi::CVI: the stateful information of the ICVI providing the criterion value.\nsample::RealVector: the sample provided to the external. clustering algorithm.\nlabel::Integer: the label prescribed to the sample by the external clustering algorithm.\n\nExamples\n\n# Create a new CVI object\nmy_cvi = CH()\n# Load in data from some external source\ndata = load_some_data()\n# Cluster the data into a set of labels as an integer vector\nlabels = my_cluster_algorithm(data)\n# Iteratively compute and extract the criterion value at every step\nn_samples = length(labels)\ncriterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    sample = data[:, ix]\n    label = labels[ix]\n    criterion_values[ix] = get_icvi!(my_cvi, sample, label)\nend\n\n\n\n\n\n","category":"function"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::CVI, sample::RealVector, label::Integer)\n\nCompute the CVI parameters incrementally.\n\nThis method updates only internal parameters of the ICVI algorithm incrementally. When the criterion value itself is needed, use evaluate! and extract it from cvi.criterion_value.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI algorithm.\nsample::RealVector: a vector of features used in the external clustering algorithm.\nlabel::Integer: the label that the external clustering algorithm prescribed to the sample.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_inc!(my_cvi, data[:, 1], labels[1])\n\n\n\n\n\n","category":"function"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::CVI, data::RealMatrix, labels::IntegerVector)\n\nCompute the CVI parameters in batch.\n\nThis method updates only the internal parameters of the CVI algorithm in batch. When the criterion value itself is needed, use evaluate! and extract it from cvi.criterion_value.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI algorithm.\ndata::RealMatrix: a matrix of data where rows are features and columns are samples, used in the external clustering algorithm.\nlabels::IntegerVector: a vector of labels that the external clustering algorithm prescribed to each column in data.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_batch!(my_cvi, data, labels)\n\n\n\n\n\n","category":"function"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::CVI)\n\nCompute the criterion value of the CVI.\n\nAfter computation, the resulting criterion value can be extracted from cvi.criterion_value. The criterion value is a function of the CVI/ICVI internal parameters, so at least two classes (i.e., unique labels) must be presented to the CVI in param_inc! or param_batch! before a non-zero value is returned.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI to use for computing the criterion value.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_batch!(my_cvi, data, labels)\njulia> evaluate!(my_cvi)\njulia> my_criterion_value = my_cvi.criterion_value\n\n\n\n\n\n","category":"function"},{"location":"man/full-index/#ClusterValidityIndices.CH","page":"Index","title":"ClusterValidityIndices.CH","text":"CH\n\nThe stateful information of the Calinski-Harabasz (CH) Cluster Validity Index\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nT. Calinski and J. Harabasz, \"A dendrite method for cluster analysis,\" Communications in Statistics, vol. 3, no. 1, pp. 1–27, 1974.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.cSIL","page":"Index","title":"ClusterValidityIndices.cSIL","text":"cSIL\n\nThe stateful information of the Centroid-based Silhouette (cSIL) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nP. J. Rousseeuw, \"Silhouettes: A graphical aid to the interpretation and validation of cluster analysis,\" Journal of Computational and Applied Mathematics, vol. 20, pp. 53–65, 1987.\nM. Rawashdeh and A. Ralescu, \"Center-wise intra-inter silhouettes,\" in Scalable Uncertainty Management, E. Hüllermeier, S. Link, T. Fober et al., Eds. Berlin, Heidelberg: Springer, 2012, pp. 406–419.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.DB","page":"Index","title":"ClusterValidityIndices.DB","text":"DB\n\nThe stateful information of the Davies-Bouldin (DB) Cluster Validity Index.\n\nReferences\n\nD. L. Davies and D. W. Bouldin, \"A cluster separation measure,\" IEEE Transaction on Pattern Analysis and Machine Intelligence, vol. 1, no. 2, pp. 224–227, Feb. 1979.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.GD43","page":"Index","title":"ClusterValidityIndices.GD43","text":"GD43\n\nThe stateful information of the Generalized Dunn's Index 43 (GD43) Cluster Validity Index.\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1–12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32–57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301–315, Jun. 1998.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.PS","page":"Index","title":"ClusterValidityIndices.PS","text":"PS\n\nThe stateful information of the Partition Separation (PS) Cluster Validity Index.\n\nReferences\n\nMiin-Shen Yang and Kuo-Lung Wu, \"A new validity index for fuzzy clustering,\" 10th IEEE International Conference on Fuzzy Systems. (Cat. No.01CH37297), Melbourne, Victoria, Australia, 2001, pp. 89-92, vol.1.\nE. Lughofer, \"Extensions of vector quantization for incremental clustering,\" Pattern Recognit., vol. 41, no. 3, pp. 995–1011, 2008.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.rCIP","page":"Index","title":"ClusterValidityIndices.rCIP","text":"rCIP\n\nThe stateful information of the (Renyi's) representative Cross Information Potential (rCIP) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nE. Gokcay and J. C. Principe, \"A new clustering evaluation function using Renyi’s information potential,\" in Proc. Int. Conf. Acoust., Speech, Signal Process. (ICASSP), vol. 6. Jun. 2000, pp. 3490–3493.\nE. Gokcay and J. C. Principe, \"Information theoretic clustering,\" IEEE Trans. Pattern Anal. Mach. Intell., vol. 24, no. 2, pp. 158–171, Feb. 2002.\nD. Araújo, A. D. Neto, and A. Martins, \"Representative cross information potential clustering,\" Pattern Recognit. Lett., vol. 34, no. 16, pp. 2181–2191, Dec. 2013.\nD. Araújo, A. D. Neto, and A. Martins, \"Information-theoretic clustering: A representative and evolutionary approach,\" Expert Syst. Appl., vol. 40, no. 10, pp. 4190–4205, Aug. 2013.\nR. O. Duda, P. E. Hart, and D. G. Stork, Pattern Classification, 2nd ed. John Wiley & Sons, 2000.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.WB","page":"Index","title":"ClusterValidityIndices.WB","text":"WB\n\nThe stateful information of the WB-Index (WB) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nQ. Zhao, M. Xu, and P. Franti, \"Sum-of-Squares Based Cluster Validity Index and Significance Analysis,\" in Adaptive and Natural Computing Algorithms, M. Kolehmainen, P. Toivanen, and B. Beliczynski, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009, pp. 313–322.\nQ. Zhao and P. Franti, \"WB-index: A sum-of-squares based index for cluster validity,\" Data Knowledge Engineering, vol. 92, pp. 77–89, 2014.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.XB","page":"Index","title":"ClusterValidityIndices.XB","text":"XB\n\nThe stateful information of the Xie-Beni (XB) Cluster Validity Index.\n\nReferences\n\nX. L. Xie and G. Beni, \"A Validity Measure for Fuzzy Clustering,\" IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 13, no. 8, pp. 841–847, 1991.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1–23, 2018.\n\n\n\n\n\n","category":"type"},{"location":"man/guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"man/guide/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI package can be installed using the Julia package manager. From the Julia REPL, type ']' to enter the Pkg REPL mode and run","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"pkg> add CVI","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Alternatively, it can be added to your environment in a script with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"using Pkg\nPkg.add(\"CVI\")","category":"page"},{"location":"man/guide/#Quickstart","page":"Guide","title":"Quickstart","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"This section provides a quick overview of how to use the project. For more detailed code usage, please see Usage. For a variety of detailed examples that you can run yourself, please see the Examples page.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"First, assume that you have a dataset of features/data and labels prescribed by some clustering algorithm:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"data_file = \"path/to/data.csv\"\ndata, labels = get_cvi_data(data_file)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"All CVI objects in this package are acronymed versions of their full names, which can be found in the Index. You can create a new CVI structure with a default constructor:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Davies-Bouldin (DB)\nmy_cvi = DB()","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The output of CVIs are called criterion values, and they can be computed incrementally with get_icvi","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"n_samples = length(labels)\ncriterion_values = zeros(n_samples)\nfor i = 1:n_samples\n    criterion_values[i] = get_icvi(data[:, i], labels[i])\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or in batch with get_cvi","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_value = get_cvi(data, labels)","category":"page"},{"location":"man/guide/#usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The usage of these CVIs requires an understanding of:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Data assumptions of the CVIs.\nHow to instantiate the CVIs.\nIncremental vs. batch evaluation.\nUpdating internal CVI parameters.\nComputing and extracting the criterion values.\nPorcelain functions that are available to simplify operation.","category":"page"},{"location":"man/guide/#data","page":"Guide","title":"Data","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Because Julia is programmed in a column-major fashion, all CVIs make the assumption that the first dimension (columns) contains features, while the second dimension (rows) contains samples. This is more important for batch operation, as incremental operation accepts 1-D sample of features at each time step by definition.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example,","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Load data from somewhere\ndata = load_data()\n# The data shape is dimsion x samples\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nAs of ClusterValidityIndices.jl v0.1.3, all the CVIs assume that the labels are presented sequentially initially, starting with index 1 (e.g., 1, 1, 2, 2, 3, 2, 2, 1, 3, 4, 4 ...). You may repeat previously seen label indices, but skipping label indices (e.g., 1, 2, 4) results in undefined behavior.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"In this project, this is ameliorated with the function","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"relabel_cvi_data(labels::Array{M, 1}) where {M<:Int}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example,","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"data_file = \"path/to/data.csv\"\ndata, labels = get_cvi_data(data_file)\nlabels = relabel_cvi_data(labels)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Alternatively, you may pairwise sort the entirety of the data with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"sort_cvi_data(data::Array{N, 2}, labels::Array{M, 1}) where {N<:Real, M<:Int}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nsort_cvi_data reorders the input data as well, which will lead to different ICVI results than with relabel_cvi_data.","category":"page"},{"location":"man/guide/#instantiation","page":"Guide","title":"Instantiation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The names of each CVI are capital abbreviations of their literature names, often based upon the surname of the principal authors of the papers that introduce the metrics. All CVIs are implemented with the default constructor, such as","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cvi = DB()","category":"page"},{"location":"man/guide/#inc-batch","page":"Guide","title":"Incremental vs. Batch","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVIs in this project all contain incremental and batch implementations. When evaluated in incremental mode, they are often called ICVIs (incremental cluster validity indices). In this documentation, CVI means batch and ICVI means incremental, though both are CVI objects.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The funtions that differ between the two modes are how they are updated:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nparam_inc!(cvi::CVI, sample::RealVector, label::Integer)\n# Batch\nparam_batch!(cvi::CVI, data::RealMatrix, labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"After updating their internal parameters, they both compute their most recent criterion values with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"evaluate!(cvi::CVI)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"To simplify the process, both modes have their respective \"porcelain\" functions to update the internal parameters, evaluate the criterion value, and return it:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nget_icvi!(cvi::CVI, sample::RealVector, label::Integer)\n# Batch\nget_cvi!(cvi::CVI, data::RealMatrix, labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nAny CVI object can be updated incrementally or in batch, as the CVIs are equivalent to their ICVI counterparts after all data is presented.","category":"page"},{"location":"man/guide/#updating","page":"Guide","title":"Updating","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVIs in this project all contain internal parameters that must be updated. Each update function modifies the CVI, so they use the Julia nomenclature convention of appending an exclamation point to indicate as much.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"In both incremental and batch modes, the parameter update requires:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI being updates\nThe sample (or array of samples)\nThe label(s) that was/were prescribed by the clustering algorithm to the sample(s)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"More concretely, they are","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental updating\nparam_inc!(cvi::CVI, sample::RealVector, label::Integer)\n# Batch updating\nparam_batch!(cvi::CVI, data::RealMatrix, labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Every CVI is a subtype of the abstract type CVI. For example, we may instantiate and load our data","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cvi = DB()\ndata = load_data()\nlabels = get_cluster_labels(data)\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"then update the parameters incrementally with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Iterate over all samples\nfor ix = 1:n_samples\n    sample = data[:, ix]\n    label = labels[ix]\n    param_inc!(cvi, sample, labels)\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or in batch with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"param_batch!(cvi, data, labels)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Furthermore, any CVI can alternate between being updated in incremental or batch modes, such as","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Create a new CVI\ncvi_mixed = DB()\n\n# Update on half of the data incrementally\ni_split = n_samples/2\nfor ix = 1:i_split\n    param_inc!(cvi, data[:, ix], labels[ix])\nend\n\n# Update on the other half all at once\nparam_batch!(cvi, data[:, (i_split+1):end])","category":"page"},{"location":"man/guide/#criterion-values","page":"Guide","title":"Criterion Values","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI parameters are separate from the criterion values that they produce. This is partly because in batch mode computing the criterion value is only relevant at the last step, which eliminates unnecessarily computing it at every step. This is also provide granularity to the user that may only which to extract the criterion value occasionally during incremental mode.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Because the criterion values only depend on the internal CVI parameters, they are computed (and internally stored) with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"evaluate!(cvi::C) where {C<:CVI}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"To extract them, you must then simply grab the criterion value from the CVI struct with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_value = cvi.criterion_value","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, after loading the data","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cvi = DB()\ndata = load_data()\nlabels = get_cluster_labels(data)\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"we may extract and return the criterion value at every step with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    param_inc!(cvi, data[:, ix], labels[ix])\n    evaluate!(cvi)\n    criterion_values[ix] = cvi.criterion_value\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or we may get it at the end in batch mode with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"param_batch!(cvi, data, labels)\nevaluate!(cvi)\ncriterion_value = cvi.criterion_value","category":"page"},{"location":"man/guide/#porcelain","page":"Guide","title":"Porcelain","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Taken from the git convention of calling low-level operations plumbing and high-level user-land functions porcelain, the package comes with a small set of porcelain function that do common operations all at once for the user.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, you may compute, evalute, and return the criterion value all at once with the functions","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nget_icvi!(...)\n# Batch\nget_cvi!(...)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Exactly as in the usage for updating the parameters, the functions take the cvi, sample(s), and clustered label(s) as input:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nget_icvi!(cvi::C, x::Array{N, 1}, y::M) where {C<:CVI, N<:Real, M<:Int}\n# Batch\nget_cvi!(cvi::C, x::Array{N, 2}, y::Array{M, 1}) where {C<:CVI, N<:Real, M<:Int}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, after loading the data you may get the criterion value at each step with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    criterion_values[ix] = get_icvi!(cvi, data[:, ix], labels[ix])\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or you may get the final criterion value in batch mode with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_value = get_cvi!(cvi, data, labels)","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section contains some examples using the ClusterValidityIndices.jl package with topics ranging from how to the internals of package work to practical examples on different datasets.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Basic-CVI/ICVI-Examples","page":"Examples","title":"Basic CVI/ICVI Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples demonstrate basic usage of the ClusterValidityIndices.jl package, such as how to run CVIs incrementally and in batch.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card\">\n<div class=\"card-cover\">\n<div class=\"card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo is a simple example of how to use a CVI in batch mode.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CVI Simple Example","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card\">\n<div class=\"card-cover\">\n<div class=\"card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo is a simple example of how to use a CVI in batch mode.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ICVI Simple Example","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/#Advanced-CVI/ICVI-Examples","page":"Examples","title":"Advanced CVI/ICVI Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples demonstrate some more advanced ins-and-outs of the ClusterValidityIndices.jl package, such as how various ICVIs compare to one another.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card\">\n<div class=\"card-cover\">\n<div class=\"card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo illustrates how to use incremental training methods vs. batch training for all ART modules. This demo also demonstrates how the final results of each CVI and ICVI are equivalent.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CVI-ICVI Comparison","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card\">\n<div class=\"card-cover\">\n<div class=\"card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo illustrates the differing behavior of each ICVI.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multi-ICVI Comparisons","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"There are examples for every structure in the package within the package's examples/ folder. The code for several of these examples is provided here.","category":"page"},{"location":"man/examples/#CVI-Full-Usage-Example","page":"Examples","title":"CVI Full Usage Example","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Consider that you already have a dataset that is labeled by some clustering algorithm. This is not strictly necessary in practice, as the incremental variants of each CVI are designed to be able to run online alongside a clustering process, but we do so here for simplicity. We treat the labels here as clustering-prescribed labels rather than true supervised labels, and we treat the data as the samples that were used to cluster to those labels.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We begin by loading the module and loading the data wherever it may be:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Load the CVI/ICVI module\nusing ClusterValidityIndices\n\n# Point to the data file\ndata_path = \"data/correct_partition.csv\"\n\n# Load the data and labels\ndata, labels = get_cvi_data(data_path)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Because Julia is column-major in memory and our data samples are potentially large, we follow the Julia notation and treat the dimensions of data as [dim, n_samples].","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"note: Note\nAs of ClusterValidityIndices.jl v0.1.5, all the CVIs assume that the labels are presented sequentially initially, starting with index 1 (e.g., 1, 1, 2, 2, 3, 2, 2, 1, 3, 4, 4 ...). You may repeat previously seen label indices, but skipping label indices (e.g., 1, 2, 4) results in undefined behavior. If your data does not accomodate this,we may circumvent this by relabelling the data monotonically withlabels = relabel_cvi_data(labels)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We can get the number of samples from the length of the labels vector because each data sample corresponds to a label:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Get the number of samples for incremental iteration\nn_samples = length(labels)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We are now ready to instantiate our CVI with default parameters. Because we have incremental and batch variants, we will instantiate two CVI models, train one sequentially and one in batch, and show that their results are equivalent. We will use the Davies-Bouldin CVI/ICVI as an example here, but all CVIs in this package have the same usage.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Create two containers for the batch and incremental CVIs\ncvi_i = DB()\ncvi_b = DB()","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We will preallocate an array for the criterion values of the incremental variant so that we can populate it iteratively.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Create some storage for our criterion values\ncriterion_values_i = zeros(n_samples)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We are now ready to evaluate the ICV incrementally, which we can to in one of two ways. Most simply, we can use get_icvi! function to evaluate the ICVI and return the criterion value all at once.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Iterate across all samples\nfor ix = 1:n_samples\n    # Update the CVI parameters and extract the criterion value in one function\n    criterion_values_i[ix] = get_icvi!(cvi_i, data[:, ix], labels[ix])\nend","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"If you desire more granularity, you can separately update the internal parameters of the CVI, evaluate those internal parameters into a criterion value, and extract that criterion value from the CVI.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Iterate across all of the samples\nfor ix = ProgressBar(1:n_samples)\n    # Update the CVI internal parameters incrementally\n    param_inc!(cvi_i, data[:, ix], labels[ix])\n    # Evaluate the CVI to internally store the criterion value\n    evaluate!(cvi_i)\n    # Extract and save the criterion value at each step\n    criterion_values_i[ix] = cvi_i.criterion_value\nend","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"If we wish to do all of this in batch, we have methods that correspond to their incremental counterparts at a high level:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Update and extract the criterion value all at once\ncriterion_value_b = get_cvi!(cvi_b, data[data_path], labels[data_path])","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"and at a more granular level:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Compute the parameters in batch\nparam_batch!(cvi_b, data, labels)\n\n# Evaluate the CVI criterion value\nevaluate!(cvi_b)\n\n# Extract the criterion value\ncriterion_value = cvi_b.criterion_value","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: header)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ClusterValidityIndices.jl","page":"Home","title":"ClusterValidityIndices.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These pages serve as the official documentation for the ClusterValidityIndices.jl Julia package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cluster Validity Indices (CVI) tackle the problem of judging the performance of an unsupervised/clustering algorithm without the availability of truth or supervisory labels, resulting in metrics of under- or over-partitioning. Furthermore, Incremental CVIs (ICVI) are variants of these ordinarily batch algorithms that enable an online and computationally tractable method of evaluating the performance of a clustering algorithm as it clusters while being numerically equivalent to their batch counterparts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is to provide a home for the development and use of these CVIs and ICVIs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation is split into the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/guide.md\",\n    \"man/examples.md\",\n    \"man/contributing.md\",\n    \"man/full-index.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Package Guide provides a tutorial to the full usage of the package, while Examples gives sample workflows using a variety of ART modules.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instructions on how to contribute to the package are found in Contributing, and docstrings for every element of the package is listed in the Index.","category":"page"}]
}
