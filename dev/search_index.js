var documenterSearchIndex = {"docs":
[{"location":"examples/cvis/cvi-icvi/#cvi_icvi","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/cvis/cvi-icvi/#Overview","page":"CVI-ICVI Comparison","title":"Overview","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"This demo is a simple example of how to use CVIs incrementally and in batch to demonstrate that the end results are the same. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. In the incremental case, we will take advantage of the fact that we can compute a criterion value at every step by running the ICVI alongside an online clustering algorithm. This simple example demonstrates the usage of a single CVI/ICVI, but it may be substituted for any other CVI/ICVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/cvis/cvi-icvi/#Data-Setup","page":"CVI-ICVI Comparison","title":"Data Setup","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing DataFrames                # DataFrames, necessary for MLDatasets.Iris()\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"iris = Iris(as_df=false)\nfeatures, labels = iris.features, iris.targets","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:}","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"labels = convertlabel(LabelEnc.Indices{Int}, vec(labels))\nunique(labels)","category":"page"},{"location":"examples/cvis/cvi-icvi/#CVI/ICVI-Setup","page":"CVI-ICVI Comparison","title":"CVI/ICVI Setup","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Because CVI/ICVIs only differ in their evaluation mode, we will use the same default constructor for both of our objects. Here, we will use the same type of CVI for both objects to verify that the results of both are the same at the final iteration.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Create both CVI objects, using one incrementally as an ICVI\nicvi = CH()\ncvi = CH()","category":"page"},{"location":"examples/cvis/cvi-icvi/#Online-Clustering","page":"CVI-ICVI Comparison","title":"Online Clustering","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/#Adaptive-Resonance-Theory-Algorithms","page":"CVI-ICVI Comparison","title":"Adaptive Resonance Theory Algorithms","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Create a Distributed Dual-Vigilance Fuzzy ART (DDVFA) module with default options\nart = DDVFA()\ntypeof(art)","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Because we are streaming clustering, we must setup the internal data setup of the DDVFA module. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Setup the data configuration for the module\ndata_setup!(art.config, features)\n# Verify that the data is setup\nart.config.setup","category":"page"},{"location":"examples/cvis/cvi-icvi/#Iteration","page":"CVI-ICVI Comparison","title":"Iteration","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"We can now cluster and get the criterion values online We will do this by creating an ICVI object, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Setup the online/streaming clustering\nn_samples = length(labels)          # Number of samples\nc_labels = zeros(Int, n_samples)    # Clustering labels\ncriterion_values = zeros(n_samples) # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Cluster the sample online\n    c_labels[ix] = train!(art, sample)\n    # Get the new criterion value (ICVI output)\n    criterion_values[ix] = get_cvi!(icvi, sample, c_labels[ix])\nend\n\n# See the list of criterion values\ncriterion_values","category":"page"},{"location":"examples/cvis/cvi-icvi/#Batch-Evaluation","page":"CVI-ICVI Comparison","title":"Batch Evaluation","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"In batch mode, we will use the sample features and prescribed cluster labels as before to verify that the criterion values are the same at the last iteration.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Get the final criterion value in batch\nbatch_criterion_value = get_cvi!(cvi, features, c_labels)","category":"page"},{"location":"examples/cvis/cvi-icvi/#Comparison","page":"CVI-ICVI Comparison","title":"Comparison","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Now we check that the two produce the same results in the end.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Print the batch result and the final result of the incremental variant\n@printf \"Batch criterion value: %.4f\\n\" batch_criterion_value\n@printf \"Final incremental criterion value: %.4f\\n\" criterion_values[end]","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"getting-started/basic-example/#Basic-Example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"This page gives a basic overview of a workflow using CVIs. For more detailed and interactive examples that you can run on your own in Julia notebooks, see the Examples section.","category":"page"},{"location":"getting-started/basic-example/#CVI-Full-Usage-Example","page":"Basic Example","title":"CVI Full Usage Example","text":"","category":"section"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"Consider that you already have a dataset that is labeled by some clustering algorithm. This is not strictly necessary in practice, as the incremental variants of each CVI are designed to be able to run online alongside a clustering process, but we do so here for simplicity. We treat the labels here as clustering-prescribed labels rather than true supervised labels, and we treat the data as the samples that were used to cluster to those labels.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"We begin by loading the module and creating some made up clustering data:","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Load the CVI/ICVI module\nusing ClusterValidityIndices\n\n# Generate some random data as an example\n# Here, we have 10 samples with feature dimenison 3\ndim = 3\nn_samples = 10\ndata = rand(dim, n_samples)\nlabels = collect(1:n_samples)","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"Because Julia is column-major in memory, we follow the Julia notation and treat the dimensions of data as [dim, n_samples].","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"We are now ready to instantiate our CVI with default parameters. Because we have incremental and batch variants, we will instantiate two CVI models, train one sequentially and one in batch, and show that their results are equivalent. We will use the Davies-Bouldin CVI/ICVI as an example here, but all CVIs in this package have the same usage.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Create two containers for the batch and incremental CVIs\ncvi_i = DB()\ncvi_b = DB()","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"We will preallocate an array for the criterion values of the incremental variant so that we can populate it iteratively.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Create some storage for our criterion values\ncriterion_values_i = zeros(n_samples)","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"We are now ready to evaluate the ICVI incrementally, which we can to in one of two ways. Most simply, we can use the get_cvi! function to evaluate the ICVI and return the criterion value all at once.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Iterate across all samples\nfor ix = 1:n_samples\n    # Update the CVI parameters and extract the criterion value in one function\n    criterion_values_i[ix] = get_icvi!(cvi_i, data[:, ix], labels[ix])\nend","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"If we wish to do all of this in batch, we use the same get_cvi! function but pass it a 2-D batch of data and vector of corresponding integer labels:","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Update and extract the criterion value all at once\ncriterion_value_b = get_cvi!(cvi_b, data, labels)","category":"page"},{"location":"getting-started/basic-example/#example-advanced-usage","page":"Basic Example","title":"Advance Usage","text":"","category":"section"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"If you desire more granularity, you can separately update the internal parameters of the CVI, evaluate those internal parameters into a criterion value, and extract that criterion value from the CVI. For details, see the Advanced Usage section.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"For example:","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Iterate across all of the samples\ncriterion_values_i = zeros(n_samples)\nfor ix = 1:n_samples\n    # Update the CVI internal parameters incrementally\n    param_inc!(cvi_i, data[:, ix], labels[ix])\n    # Evaluate the CVI to internally store the criterion value\n    evaluate!(cvi_i)\n    # Extract and save the criterion value at each step\n    criterion_values_i[ix] = cvi_i.criterion_value\nend","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"In batch mode, this would also be:","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Compute the parameters in batch\nparam_batch!(cvi_b, data, labels)\n\n# Evaluate the CVI criterion value\nevaluate!(cvi_b)\n\n# Extract the criterion value\ncriterion_value_b = cvi_b.criterion_value","category":"page"},{"location":"man/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"This page serves as the contribution guide for the ClusterValidityIndices.jl package. From top to bottom, the ways of contributing are:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"GitHub Issues: how to raise an issue with the project.\nJulia Development: how to download and interact with the package.\nGitFlow: how to directly contribute code to the package in an organized way on GitHub.\nDevelopment Details: how the internals of the package are currently setup if you would like to directly contribute code.","category":"page"},{"location":"man/contributing/#Issues","page":"Contributing","title":"Issues","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The main point of contact is the GitHub issues page for the project. This is the easiest way to contribute to the project, as any issue you find or request you have will be addressed there by the authors of the package. Depending on the issue, the authors will collaborate with you, and after making changes they will link a pull request which addresses your concern or implements your proposed changes.","category":"page"},{"location":"man/contributing/#Julia-Development","page":"Contributing","title":"Julia Development","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"As a Julia package, development follows the usual procedure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Clone the project from GitHub\nSwitch to or create the branch that you wish work on (see GitFlow).\nStart Julia at your development folder.\nInstantiate the package (i.e., download and install the package dependencies).","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"For example, you can get the package and startup Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"git clone git@github.com:AP6YC/ClusterValidityIndices.jl.git\njulia --project=.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIn Julia, you must activate your project in the current REPL to point to the location/scope of installed packages. The above immediately activates the project when starting up Julia, but you may also separately startup the julia and activate the package with the interactive package manager via the ] syntax:julia> ]\n(@v1.8) pkg> activate .\n(ClusterValidityIndices) pkg>","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"You may run the package's unit tests after the above setup in Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> using Pkg\njulia> Pkg.instantiate()\njulia> Pkg.test()","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"or interactively though the Julia package manager with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> ]\n(ClusterValidityIndices) pkg> instantiate\n(ClusterValidityIndices) pkg> test","category":"page"},{"location":"man/contributing/#GitFlow","page":"Contributing","title":"GitFlow","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The ClusterValidityIndices.jl package follows the GitFlow git working model. The original post by Vincent Driessen outlines this methodology quite well, while Atlassian has a good tutorial as well. In summary:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Create a feature branch off of the develop branch with the name feature/<my-feature-name>.\nCommit your changes and push to this feature branch.\nWhen you are satisfied with your changes, initiate a GitHub pull request (PR) to merge the feature branch with develop.\nIf the unit tests pass, the feature branch will first be merged with develop and then be deleted.\nReleases will be periodically initiated from the develop branch and versioned onto the master branch.\nImmediate bug fixes circumvent this process through a hotfix branch off of master.","category":"page"},{"location":"man/contributing/#Development-Details","page":"Contributing","title":"Development Details","text":"","category":"section"},{"location":"man/contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"These docs are currently hosted as a static site on the GitHub pages platform. They are setup to be built and served in a separate branch gh-pages from the master/development branch of the project.","category":"page"},{"location":"man/contributing/#Package-Structure","page":"Contributing","title":"Package Structure","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The ClusterValidityIndices.jl package has the following file structure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"ClusterValidityIndices.jl\n├── .github/workflows       // GitHub: workflows for testing and documentation.\n├── data                    // Data: CI and example data location.\n├── docs                    // Docs: GitHub pages documentation files.\n├── paper                   // Docs: JOSS paper and bib files.\n├── src                     // Source: scripts and common helper functions.\n│   └─── CVI                //      All CVI and ICVI definitions\n├── test                    // Test: unit, integration, and environment tests.\n├── .appveyor               // CI: Appveyor CI script\n├── .gitignore              // Git: .gitignore for the whole project.\n├── CODE_OF_CONDUCT         // Doc: the expectations of contributors to the project.\n├── CONTRIBUTING            // Doc: a summary of contribution guidelines, pointing to these docs.\n├── LICENSE                 // Doc: the license to the project.\n├── Manifest.toml           // Julia: the explicit package versions used (ignored).\n├── Project.toml            // Julia: the Pkg.jl dependencies of the project.\n└── README.md               // Doc: the README.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"All CVIs are implemented in separate files in the src/CVI/ directory, and they are imported to src/ClusterValidityIndices.jl through imports in src/CVI/CVI.jl.","category":"page"},{"location":"man/contributing/#Dependencies","page":"Contributing","title":"Dependencies","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Several dependencies directly affect the look and functionality of the project's codebase, so their special considerations are listed below.","category":"page"},{"location":"man/contributing/#NumericalTypeAliases.jl","page":"Contributing","title":"NumericalTypeAliases.jl","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The ClusterValidityIndices.jl package uses the NumericalTypeAliases.jl package for the definition of convenient aliases for numerical types, such as those restricting real-valued matrices and integer-valued vectors.","category":"page"},{"location":"man/contributing/#DocStringExtensions.jl","page":"Contributing","title":"DocStringExtensions.jl","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The ClusterValidityIndices.jl package makes heavy use of DocStringExtensions.jl for the documentation of its CVIs. This includes the definitions of docstring templates that depend on the type being documented.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Documentation for the project uses the following workflow:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Each type and function requires a description, possible arguments list, and citations (where applicable).\nSignatures and methodlists autopopulate, so they should not be explicitly written at the risk of duplication.\nTypes should have docstrings for every field, which should include boundary values where applicable.","category":"page"},{"location":"man/contributing/#CVI-Module-Workflow","page":"Contributing","title":"CVI Module Workflow","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"To write a CVI for this project, it will require the following:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"A struct subtyped from CVI that implements the internal parameters in addition to a Float named criterion_value and a LabelMap.\nA default constructor that initializes values to zeros and arrays to empties (see existing CVI files such as DB.jl for examples).\nAn incremental parameter update method param_inc!(cvi::NEW_CVI, sample::RealVector, label::Integer) where NEW_CVI is the name of the new CVI.\nA batch parameter update method param_batch!(cvi::NEW_CVI, data::RealMatrix, labels::IntegerVector).\nA criterion value evaluation method evaluate(cvi::NEW_CVI) that updates the internal criterion value.\nThe top-level functions get_icvi and get_cvi will work automatically after writing the above definitions!","category":"page"},{"location":"man/contributing/#Authors","page":"Contributing","title":"Authors","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"If you simply have suggestions for improvement, Sasha Petrenko (<sap625@mst.edu>) is the current developer and maintainer of the ClusterValidityIndices.jl package, so please feel free to reach out with thoughts and questions.","category":"page"},{"location":"man/guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The package guide is broken into the following sections:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Installation: instructions for the package.\nQuickstart: a simple rundown of the package usage to get it running.\nUsage: a deep dive of the package and its detailed usage.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For a list of all implemented batch and incremental CVIs available in the package, see the Implemented CVI List page.","category":"page"},{"location":"man/guide/#guide-installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"This project is distributed as a Julia package and hosted on JuliaHub, Julia's package manager repository. As such, this package's usage follows the usual Julia package installation procedure, interactively:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"julia> ]\n(@v1.8) pkg> add ClusterValidityIndices","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or programmatically:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"julia> using Pkg\njulia> Pkg.add(\"ClusterValidityIndices\")","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"You may also add the package directly from GitHub to get the latest changes between releases:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"julia> ]\n(@v1.8) pkg> add https://github.com/AP6YC/ClusterValidityIndices.jl","category":"page"},{"location":"man/guide/#guide-quickstart","page":"Guide","title":"Quickstart","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"This section provides a quick overview of how to use the project. For more detailed code usage, please see the Usage section. For a variety of detailed examples that you can run yourself, please see the Examples page.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"First, import the package with:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Import the package\nusing ClusterValidityIndices","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"CVI objects are instantiated with empty constructors:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Create a Davies-Bouldin (DB) CVI object\nmy_cvi = DB()","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"All CVIs are implemented with acronyms of their literature names. A list of all of these are found in the Implemented CVI List page, and their code details can be found in the Index.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Next, get data from a clustering process. This is a set of samples of features that are clustered and prescribed cluster labels.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nThe ClusterValidityIndices.jl package assumes data to be in the form of Float matrices where columns are samples and rows are features. An individual sample is a single vector of features. Labels are vectors of integers where each number corresponds to its own cluster.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Random data as an example; 10 samples with feature dimenison 3\ndim = 3\nn_samples = 10\ndata = rand(dim, n_samples)\nlabels = repeat(1:2, inner=n_samples)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The output of CVIs are called criterion values, and they can be computed both incrementally and in batch with get_cvi!. Compute in batch by providing a matrix of samples and a vector of labels:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_value = get_cvi!(my_cvi, data, labels)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or incrementally with the same function by passing one sample and label at a time:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Create a fresh CVI object for incremental evaluation\nmy_icvi = DB()\n\n# Create a container for the values and iterate\ncriterion_values = zeros(n_samples)\nfor i = 1:n_samples\n    criterion_values[i] = get_cvi!(my_icvi, data[:, i], labels[i])\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nEach module has a batch and incremental implementation, but ClusterValidityIndices.jl does not yet support switching between batch and incremental modes with the same CVI object.","category":"page"},{"location":"man/guide/#usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The usage of these CVIs covers the following:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Data assumptions of the CVIs.\nHow to instantiate the CVIs.\nIncremental vs. batch evaluation.\nAdvanced usage for under-the-hood.","category":"page"},{"location":"man/guide/#guide-data","page":"Guide","title":"Data","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Because Julia is programmed in a column-major fashion, all CVIs make the assumption that the first dimension (columns) contains features, while the second dimension (rows) contains samples. This is more important for batch operation, as incremental operation accepts a 1-D sample of features at each time step by definition.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example,","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Load data from somewhere\ndata = load_data()\n# The data shape is dimsion x samples\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/#guide-instantiation","page":"Guide","title":"Instantiation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The names of each CVI are capital abbreviations of their literature names, often based upon the surname of the principal authors of the papers that introduce the metrics. Every CVI is a subtype of the abstract type CVI, and they are all are instantiated with the empty constructor:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"my_cvi = DB()","category":"page"},{"location":"man/guide/#guide-inc-batch","page":"Guide","title":"Incremental vs. Batch","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVIs in this project all contain incremental and batch implementations. When evaluated in incremental mode, they are often called ICVIs (incremental cluster validity indices) in the literature. For simplicity, all CVI objects have batch and incremental implementations and are simply referred to as CVIs in the documentation.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Either way, you use get_cvi!, and the magic of Julia's multiple dispatch handles which implementation to use. To update in batch, you must provide a 2D matrix of samples along with a vector of integer labels. To update incrementally, simply provide a single sample with an integer label.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Batch\nget_cvi!(cvi::CVI, data::RealMatrix, labels::IntegerVector)\n# Incremental\nget_cvi!(cvi::CVI, sample::RealVector, label::Integer)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"In both incremental and batch modes, the parameter update requires:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI being updated.\nThe sample (or array of samples).\nThe label(s) that was/were prescribed by the clustering algorithm to the sample(s).","category":"page"},{"location":"man/guide/#guide-advanced-usage","page":"Guide","title":"Advanced Usage","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nThis section is for advanced usage of the internal API, documented in the Developer Index. Though not part of the public API, internal CVI update usage is documented here for advanced use-cases.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVIs in this project all contain internal parameters that must be updated. Each update function modifies the CVI, so they use the Julia nomenclature convention of appending an exclamation point to indicate as much.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"param_inc!/param_batch!: updates the internal parameters of the CVI.\nevaluate!: computes the criterion value itself.\ncvi.criterion_value: contains the last criterion value after evaluation.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"More concretely, they are","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental updating\nClusterValidityIndices.param_inc!(cvi::CVI, sample::RealVector, label::Integer)\n# Batch updating\nClusterValidityIndices.param_batch!(cvi::CVI, data::RealMatrix, labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"After updating their internal parameters, they both compute their most recent criterion values with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"ClusterValidityIndices.evaluate!(cvi::CVI)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"which are then stored cvi.criterion_value as a floating point value.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, we may instantiate and load our data","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Create a local CVI object\ncvi = DB()\n\n# Generate random data as an example; 10 samples with feature dimenison 3\ndim = 3\nn_samples = 10\ndata = rand(dim, n_samples)\nlabels = repeat(1:2, inner=n_samples)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"then update the parameters incrementally with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    ClusterValidityIndices.param_inc!(cvi, data[:, ix], labels[ix])\n    ClusterValidityIndices.evaluate!(cvi)\n    criterion_values[ix] = cvi.criterion_value\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or in batch with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"ClusterValidityIndices.param_batch!(cvi, data, labels)\nClusterValidityIndices.evaluate!(cvi)\ncriterion_value = cvi.criterion_value","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nThough this advanced usage is already done all at once with get_cvi!, one possible use of this advanced usage is saving computation. For example, one might wish to update the CVI internal parameters incrementally each step with param_inc! but save the computation of the criterion value itself until it is required with evaluate!. In all other instances, it is recommended to utilize the public API with get_cvi!.","category":"page"},{"location":"examples/cvis/clustering-comparison/#clustering_comparison","page":"Clustering Comparison","title":"Clustering Comparison","text":"","category":"section"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/cvis/clustering-comparison/#Overview","page":"Clustering Comparison","title":"Overview","text":"","category":"section"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"This demo shows how to use CVIs to measure how two online clustering processes can differ. Here, we load a simple dataset and run two clustering algorithms to prescribe a set of clusters to the features. We will also compute their respective criterion values in-the-loop. Though this simple example demonstrates the usage of a single CVI, it may be substituted for any other CVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/cvis/clustering-comparison/#Clustering","page":"Clustering Comparison","title":"Clustering","text":"","category":"section"},{"location":"examples/cvis/clustering-comparison/#Data-Setup","page":"Clustering Comparison","title":"Data Setup","text":"","category":"section"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing DataFrames                # DataFrames, necessary for MLDatasets.Iris()\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing\nusing Plots                     # Plots frontend\ngr()                            # Use the default GR backend explicitly\ntheme(:dracula)                 # Change the theme for fun","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"iris = Iris(as_df=false)\nfeatures, labels = iris.features, iris.targets","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:}","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"labels = convertlabel(LabelEnc.Indices{Int}, vec(labels))\nunique(labels)","category":"page"},{"location":"examples/cvis/clustering-comparison/#ART-Online-Clustering","page":"Clustering Comparison","title":"ART Online Clustering","text":"","category":"section"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"We will create two Distributed Dual-Vigilance Fuzzy ART (DDVFA) modules with two different options for comparison.","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"# Create a list of two DDVFA modules with different options\narts = [\n    DDVFA()                         # Default options\n    DDVFA(rho_lb=0.6, rho_ub=0.7)   # Specified options\n]\ntypeof(arts)","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"Because we are streaming clustering, we must setup the internal data setup of both of the modules. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"# Setup the data configuration for both modules\nfor art in arts\n    data_setup!(art, features)\nend","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"We can now cluster and get the criterion values online. We will do this by creating two CVI objects for both clustering modules, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"# Create two CVI objects, one for each clustering module\nn_cvis = length(arts)\ncvis = [CH() for _ = 1:n_cvis]\n\n# Setup the online/streaming clustering\nn_samples = length(labels)                  # Number of samples\nc_labels = zeros(Int, n_samples, n_cvis)     # Clustering labels for both\ncriterion_values = zeros(n_samples, n_cvis)  # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Iterate over all clustering algorithms and CVIs\n    for jx = 1:n_cvis\n        # Cluster the sample online\n        local_label = train!(arts[jx], sample)\n        c_labels[ix, jx] = local_label\n        # Get the new criterion value (ICVI output)\n        criterion_values[ix, jx] = get_cvi!(cvis[jx], sample, local_label)\n    end\nend\n\n# See the list of criterion values\ncriterion_values","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"Because we ran it iteratively, we can also see how the criterion value evolved over time in a plot!","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"# Create the plotting function\nfunction plot_icvis(criterion_values)\n    p = plot(legend=:topleft)\n    for ix = 1:n_cvis\n        plot!(\n            p,\n            1:n_samples,\n            criterion_values[:, ix],\n            linewidth = 5,\n            label = string(typeof(arts[ix])),\n            xlabel = \"Sample\",\n            ylabel = \"$(typeof(cvis[ix])) Value\",\n        )\n    end\n    return p\nend\n\n# Show the plot\np = plot_icvis(criterion_values)","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"We can clearly see that the CVIs illustrate a difference in how the two clustering algorithms operate. By changing the options of the clustering algorithms just a little bit, they cluster vastly differently, which is reflected in the difference in the ICVIs that broadens each time step.","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"png(\"assets/clustering-comparison\") #hide","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"","category":"page"},{"location":"examples/cvis/clustering-comparison/","page":"Clustering Comparison","title":"Clustering Comparison","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section contains some examples using the ClusterValidityIndices.jl package with topics ranging from how to the internals of package work to practical examples on different datasets.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Basic-CVI/ICVI-Examples","page":"Examples","title":"Basic CVI/ICVI Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples demonstrate basic usage of the ClusterValidityIndices.jl package, such as how to run CVIs incrementally and in batch.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"grid-card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"How to use a CVI in batch mode.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Batch CVI Simple Example","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"How to use a CVI incrementally (i.e., ICVI).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Incremental CVI Simple Example","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/#Advanced-CVI/ICVI-Examples","page":"Examples","title":"Advanced CVI/ICVI Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples demonstrate some more advanced ins-and-outs of the ClusterValidityIndices.jl package, such as how various ICVIs compare to one another.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"grid-card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A comparison of two clustering processes with one ICVI.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Clustering Comparison","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"How to use incremental and batch CVIs, demonstrating how the final results are equivalent.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CVI-ICVI Comparison","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A comparison of the differing behavior of each ICVI.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multi-ICVI Comparisons","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A comparison of CVIs with their equivalent implementations in the scikit-learn Python library.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ScikitLearn Comparison","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/basic-examples/icvi-example/#icvi_example","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/basic-examples/icvi-example/#Overview","page":"Incremental CVI Simple Example","title":"Overview","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"This demo is a simple example of how to use CVIs incrementally (ICVI). Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. We will take advantage of the fact that we can compute a criterion value at every step by running the ICVI alongside an online clustering algorithm. This simple example demonstrates the usage of a single ICVI, but it may be substituted for any other ICVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/basic-examples/icvi-example/#Online-Clustering","page":"Incremental CVI Simple Example","title":"Online Clustering","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/#Data-Setup","page":"Incremental CVI Simple Example","title":"Data Setup","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing DataFrames                # DataFrames, necessary for MLDatasets.Iris()\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing\nusing Plots                     # Plots frontend\ngr()                            # Use the default GR backend explicitly\ntheme(:dracula)                 # Change the theme for fun","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"iris = Iris(as_df=false)\nfeatures, labels = iris.features, iris.targets","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:}","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"labels = convertlabel(LabelEnc.Indices{Int}, vec(labels))\nunique(labels)","category":"page"},{"location":"examples/basic-examples/icvi-example/#ART-Online-Clustering","page":"Incremental CVI Simple Example","title":"ART Online Clustering","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"# Create a Distributed Dual-Vigilance Fuzzy ART (DDVFA) module with default options\nart = DDVFA()\ntypeof(art)","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"Because we are streaming clustering, we must setup the internal data setup of the DDVFA module. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"# Setup the data configuration for the module\ndata_setup!(art, features)\n# Verify that the data is setup\nart.config.setup","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"We can now cluster and get the criterion values online. We will do this by creating an ICVI object, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"# Create an ICVI object\nicvi = CH()\n\n# Setup the online/streaming clustering\nn_samples = length(labels)          # Number of samples\nc_labels = zeros(Int, n_samples)    # Clustering labels\ncriterion_values = zeros(n_samples) # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Cluster the sample online\n    c_labels[ix] = train!(art, sample)\n    # Get the new criterion value (ICVI output)\n    criterion_values[ix] = get_cvi!(icvi, sample, c_labels[ix])\nend\n\n# See the list of criterion values\ncriterion_values","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"Because we ran it iteratively, we can also see how the criterion value evolved over time in a plot!","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"# Create the plotting object\np = plot(\n    1:n_samples,\n    criterion_values,\n    linewidth = 5,\n    title = \"Incremental $(typeof(icvi)) Index\",\n    xlabel = \"Sample\",\n    ylabel = \"$(typeof(icvi)) Value\",\n)","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"Because of the visualization afforded by computing the criterion value incrementally, this plot can tell us several things. First, we see that the CVI has a value of zero until the second cluster is encountered, which makes sense because there cannot be measurements of inter-/intra-cluster separation until there is more than one cluster. Second, we see that the criterion value evolves at each time step as the clustering process occurs.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"png(\"assets/icvi-example\") #hide","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"Incremental CVI Simple Example","title":"Incremental CVI Simple Example","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/cvis/icvi-comparison/#icvi_comparison","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/cvis/icvi-comparison/#Overview","page":"Multi-ICVI Comparisons","title":"Overview","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"This demo demostrates the differing behavior of the various ICVIs implemented in ClusterValidityIndices.jl. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. We will take advantage of the fact that we can compute a criterion value at every step by running the ICVI alongside an online clustering algorithm.","category":"page"},{"location":"examples/cvis/icvi-comparison/#Online-Clustering","page":"Multi-ICVI Comparisons","title":"Online Clustering","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/#Data-Setup","page":"Multi-ICVI Comparisons","title":"Data Setup","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing DataFrames                # DataFrames, necessary for MLDatasets.Iris()\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing\nusing Plots                     # Plots frontend\ngr()                            # Use the default GR backend explicitly\ntheme(:dracula)                 # Change the theme for fun","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"iris = Iris(as_df=false)\nfeatures, labels = iris.features, iris.targets","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:}","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"labels = convertlabel(LabelEnc.Indices{Int}, vec(labels))\nunique(labels)","category":"page"},{"location":"examples/cvis/icvi-comparison/#ART-Online-Clustering","page":"Multi-ICVI Comparisons","title":"ART Online Clustering","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Create a Distributed Dual-Vigilance Fuzzy ART (DDVFA) module with default options\nart = DDVFA()\ntypeof(art)","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Because we are streaming clustering, we must setup the internal data setup of the DDVFA module. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Setup the data configuration for the module\ndata_setup!(art, features)\n# Verify that the data is setup\nart.config.setup","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We can now cluster and get the criterion values online. We will do this by creating many ICVI objects, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Create many ICVI objects\nicvis = [\n    CH(),\n    cSIL(),\n    DB(),\n    GD43(),\n    GD53(),\n    PS(),\n    rCIP(),\n    WB(),\n    XB(),\n]\n\n# Setup the online/streaming clustering\nn_samples = length(labels)          # Number of samples\nn_icvi = length(icvis)              # Number of ICVIs being computed\nc_labels = zeros(Int, n_samples)    # Clustering labels\ncriterion_values = zeros(n_icvi, n_samples) # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Cluster the sample online\n    c_labels[ix] = train!(art, sample)\n    # Get the new criterion values (ICVI output)\n    for jx = 1:n_icvi\n        criterion_values[jx, ix] = get_cvi!(icvis[jx], sample, c_labels[ix])\n    end\nend\n\n# See the matrix of criterion values\ncriterion_values","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We can inspect the final ICVI values to see how they differ:","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"criterion_values[:, end]","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Next, we would like to visualize these CVI trendlines over time with some plotting. We can try plotting these trendlines all over one another","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Define a simple function for plotting\nfunction plot_cvis(range)\n    # Create the plotting object\n    p = plot(legend=:topleft)\n    # Iterate over the range of ICVI indices provided\n    for jx = range\n        # Plot the ICVI criterion values versus sample index\n        plot!(\n            p,                              # Modify the plot object\n            1:n_samples,                    # x-axis iteration\n            criterion_values[jx, :],        # y-axis criterion value\n            linewidth=3,                    # Thicken the lines for visibility\n            label=string(typeof(icvis[jx])) # Label is the type of CVI\n        )\n    end\n    # Return the plotting object for IJulia display\n    return p\nend\n\n# Plot all of the ICVIs tested here\nplot_cvis(1:n_icvi)","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We see from the final values that the CH and cSIL metrics behave very differently from the other metrics, so we should plot them separately to see them in better detail.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Exclude CH and cSIL\nplot_cvis(3:n_icvi)","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"This plot shows that the icvis all have unique behaviors as the clustering process continues incrementally.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"png(\"assets/icvi-comparision\") #hide","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"man/cvi-list/#cvi-list-page","page":"CVI List","title":"Implemented CVI List","text":"","category":"section"},{"location":"man/cvi-list/","page":"CVI List","title":"CVI List","text":"The ClusterValidityIndices.jl package has the following CVIs implemented:","category":"page"},{"location":"man/cvi-list/","page":"CVI List","title":"CVI List","text":"CurrentModule=ClusterValidityIndices","category":"page"},{"location":"man/cvi-list/","page":"CVI List","title":"CVI List","text":"CH: Calinski-Harabasz.\ncSIL: Centroid-based Silhouette.\nDB: Davies-Bouldin.\nGD43: Generalized Dunn's Index 43.\nGD53: Generalized Dunn's Index 53.\nPS: Partition Separation.\nrCIP: (Renyi's) representative Cross Information Potential.\nWB: WB-index.\nXB: Xie-Beni.","category":"page"},{"location":"man/cvi-list/","page":"CVI List","title":"CVI List","text":"The exported constant CVI_MODULES also contains a list of these CVIs for convenient iteration.","category":"page"},{"location":"man/cvi-list/","page":"CVI List","title":"CVI List","text":"Each of the CVIs are instantiated with the empty constructor, i.e. CH() and run with get_cvi!. For details and usage, see the Package Guide.","category":"page"},{"location":"examples/basic-examples/cvi-example/#cvi_example","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/basic-examples/cvi-example/#Overview","page":"Batch CVI Simple Example","title":"Overview","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"This demo is a simple example of how to use CVIs in batch mode. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. It is a combination of these features and the prescribed labels that are used to compute the criterion value. This simple example demonstrates the usage of a single CVI, but it may be substituted for any other CVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/basic-examples/cvi-example/#Clustering","page":"Batch CVI Simple Example","title":"Clustering","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/#Data-Setup","page":"Batch CVI Simple Example","title":"Data Setup","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"using ClusterValidityIndices    # CVI/ICVI\nusing Clustering                # Fuzzy C-Means\nusing MLDatasets                # Iris dataset\nusing DataFrames                # DataFrames, necessary for MLDatasets.Iris()\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"iris = Iris(as_df=false)\nfeatures, labels = iris.features, iris.targets","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:}","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"labels = convertlabel(LabelEnc.Indices{Int}, vec(labels))\nunique(labels)","category":"page"},{"location":"examples/basic-examples/cvi-example/#Fuzzy-C-Means","page":"Batch CVI Simple Example","title":"Fuzzy C-Means","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"Get the Fuzzy C-Means clustering result","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"results = fuzzy_cmeans(features, 3, 2)","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"Because the results are fuzzy weights, find the maximum elements along each sample","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"indices = argmax(results.weights, dims=2)","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"Get those labels as a vector of integers","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"c_labels = vec([c[2] for c in indices])","category":"page"},{"location":"examples/basic-examples/cvi-example/#CVI-Criterion-Value-Extraction","page":"Batch CVI Simple Example","title":"CVI Criterion Value Extraction","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"Now that we have some data and a clustering algorithm's prescribed labels, we can compute a criterion value using a CVI in batch mode. First, we create a CVI object with the default constructor:","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"# Create a CVI object\nmy_cvi = CH()","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"Finally we can simply get the criterion value in batch by passing all of the data and Fuzzy C-Means labels at once.","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"# Get the batch criterion value\ncriterion_value = get_cvi!(my_cvi, features, c_labels)","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"Batch CVI Simple Example","title":"Batch CVI Simple Example","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"getting-started/what-are-cvis/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"This page provides a theoretical overview of cluster validity indices and what this project aims to accomplish.","category":"page"},{"location":"getting-started/what-are-cvis/#Problem-Statement","page":"Background","title":"Problem Statement","text":"","category":"section"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Consider the following: say that you have an unlabeled dataset filled with vectors of features but no predefined \"bins\" that you could organize these sampels into. The desired end result is both a statement of how many bins of samples you have and a vector of labels corresponding to each sample prescribing which bin that sample belongs to. Both of these statements are generally equivalent beyond some edge cases, but it is worth noting the distinction.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"In this case, the realms of machine learning and statistics have the answer for you: clustering! So you do your research, select a suitable clustering algorithm for your dataset, program the algorithm, and retrieve a set of labels/bins for your dataset. What you've done is no small feat, built as it is upon the shoulders of giants. However, here comes the rub: how do you know how good your resulting bins are? Do these categories accurately reflect some underlying structure to the data, or are they no better than choosing random labels for each sample?","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Your first test may be to use another clustering algorithm, and then another. It is wise to check your answer against multiple other clustering algorithms because you don't want to put all of your eggs in one basket; though all clustering algorithms have different formulations that might give different results, they should all converge to the same sort of answer if the answer is correct in any way, shouldn't they? Sometimes they do, but usually they don't; different ways of binning things together result in different biases of structure.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"If the algorithms all give different answers, then which one is correct? If they're all different, can any one of them even be considered correct in the first place? The answer, sadly, is no. By definition, we cannot know if our answer is correct if we do not have the \"true\" labels for the data, if they even exist in the first place.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Since we can't create a true performance metric to compare how our clustering algorithms do on our dataset, we must find a way to create metrics that somehow give us a number based upon the structural behavior of the clustering algorithm. Enter cluster validity indices.","category":"page"},{"location":"getting-started/what-are-cvis/#What-are-Cluster-Validity-Indices?","page":"Background","title":"What are Cluster Validity Indices?","text":"","category":"section"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Cluster Validity Indices (CVIs) are designed to tackle the problem of creating a metric of performance for unsupervised algorithms where the true answer is unknown. Clustering is a ubiquitous unsupervised learning paradigm, so the terminology and development of CVIs principally target clustering algorithms.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Because the clustering problem statement means that we do not have true labels to measure how well or poorly these algorithms perform, the most that we can do is to create a metric of the validity of the solution. This typically translates to how much an algorithm over- or under-partitions the data (i.e., how eager or reticent it is to create new categories), but some CVIs take other aspects of the structure of the solution into account, such as compactness (i.e., the density of the prescribed cluster regions) and connectedness (i.e., a measure of how much disparate points in a cluster can be said to still belong to the same category).","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"In general, CVIs take a set of samples and the labels prescribed to them by a clustering algorithm, and they return a criterion value that is generally a positive real number. This criterion value often does not have an upper bound, varies greatly in behavior between CVIs, and changes as new samples are labeled and the CVI is reprocessed. In fact, it is often the trendlines of these values that provide the most information about the clustering process rather than the values themselves.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"CVIs are originally derived to work on batches of samples and labels. However, there exist incremental variants that are proven to be mathematically equivalent to their batch counterparts. These incremental CVIs (ICVIs) mitigate the computational overhead of computing these metrics online, such as in a streaming clustering scenarios.","category":"page"},{"location":"examples/cvis/scikit-learn/#scikit-learn","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"","category":"section"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/cvis/scikit-learn/#Overview","page":"ScikitLearn Comparison","title":"Overview","text":"","category":"section"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"This demo compares CVIs that are implemented in this package with their equivalents in the scikit-learn Python package. We will generate some random distributions, cluster them with different algorithms, and demonstrate that the resulting metrics are equivalent.","category":"page"},{"location":"examples/cvis/scikit-learn/#Setup","page":"ScikitLearn Comparison","title":"Setup","text":"","category":"section"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"First, we load our dependencies.","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"# Load all dependencies\nusing ClusterValidityIndices    # This package\nusing Clustering                # k-means\nusing AdaptiveResonance         # DDVFA\nusing PyCall                    # scikit-learn interface\nusing Plots                     # Plots frontend\nusing Distributions             # Random distribution sampling\nusing LinearAlgebra             # UniformScaling\ngr()                            # Use the default GR backend explicitly\ntheme(:dracula)                 # Change the theme for fun","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"Next, we will set some configuration variables that we will use throughout the script.","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"# The number of random distributions to sample from\nn_distributions = 4\n# The number of samples per distribution that we want to draw\nn_samples_per = 20\n# The number of seed values we will use for k-means\nn_k_means = 30\n# The dimensionality of the distributions and resulting feature space\ndim = 2","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"After setting our variables, we will import the scikit-learn metrics package.","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"# Use the PyCall interface to import the metrics package\nskmetrics = pyimport(\"sklearn.metrics\")","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"Next, we will create a series of distributions for random sampling.","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"# Container for multivariate normal distributions\ndists = []\n# Iterate over the number of distributions we selected earlier\nfor i = 1:n_distributions\n    # Set a random vector mean\n    mean = 50*rand(dim)\n    # Create a positive definite matrix, guaranteeing dominance of the diagonal\n    covariance = rand(Float64, (dim, dim))\n    covariance = 0.5 * (covariance' + covariance) + UniformScaling(1)\n    # Add a new distribution to the list\n    push!(dists, MvNormal(mean, covariance))\nend","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"We then create a batch of samples from these distributions. While we are here, we can visualize the resulting sample space.","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"X = reduce(hcat, [rand(dists[i], n_samples_per) for i=1:n_distributions])\np = plot()\nscatter!(p, X[1, :], X[2, :])","category":"page"},{"location":"examples/cvis/scikit-learn/#Cluster-and-Compute-Metrics","page":"ScikitLearn Comparison","title":"Cluster and Compute Metrics","text":"","category":"section"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"Now, we are ready to do some clustering. One use of CVIs is for checking the performance of a clustering algorithm while tweaking its hyperparameters. For example, the k-means clustering algorithm is a partition/globular clustering algorithm that requires a seed number as a hyperparameter. The \"best\" seed number for a particular clustering problem varies and is usually unknown, and higher values are more computationally expensive.","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"Here, we will cluster the k-means while testing a range of seed values, comparing the equivalence of the Calinski-Harabasz (CH) metric between this package and the scikit-learn implementation.","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"# Create a range of k-mean seeds to test across along with CVI containers\nkm_range = 2:n_k_means\ncriterion_values_jl = zeros(length(km_range))\ncriterion_values_py = zeros(length(km_range))\nfor (i, n_clust) = enumerate(km_range)\n    # Get the labels prescribed k-means to each sample\n    labels_km = kmeans(X, n_clust).assignments\n\n    # Create a Calinski-Harabasz CVI and get its criterion value\n    cvi = CH()\n    criterion_values_jl[i] = get_cvi!(cvi, X, labels_km)\n\n    # Compute the criterion value with the scikit-learn implementation\n    criterion_values_py[i] = skmetrics.calinski_harabasz_score(X', labels_km)\nend\n# Show that the values are all equivalent between implementations\nisapprox(criterion_values_jl, criterion_values_py)","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"We can visualize the result as well by plotting the trendlines of the criterion values from each implementation.","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"q = plot(legend=:bottomright)\nplot!(q, km_range, criterion_values_jl, marker=:d, label=\"Julia\")\nplot!(q, km_range, criterion_values_py, marker=:d, label=\"Python\")\nylabel!(q, \"Calinski-Harabasz CVI\")\nxlabel!(q, \"K-Means Seed\")","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"After visualizing the results and seeing that the trendlines are equivalent, we also see that unsurprisingly the best k-means seed value is k=4, since we know that we are sampling from four gaussians.","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"png(\"assets/scikit-learn\") #hide","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"","category":"page"},{"location":"examples/cvis/scikit-learn/","page":"ScikitLearn Comparison","title":"ScikitLearn Comparison","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"man/dev-index/#dev-main-index","page":"Internals","title":"Developer Index","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"This page lists the types and functions that are internal to the ClusterValidityIndices.jl package. Because they are not part of the public API, these names might change relatively frequently between versions and so should not be relied upon.","category":"page"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"All internal names are listed in the Index, and each of these entries link to the docstrings in the Docs section.","category":"page"},{"location":"man/dev-index/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"This section contains a list of internal names that link to their corresponding Documentation.","category":"page"},{"location":"man/dev-index/#dev-index-methods","page":"Internals","title":"Methods","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Pages   = [\"dev-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:function]","category":"page"},{"location":"man/dev-index/#dev-index-types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Pages   = [\"dev-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:type]","category":"page"},{"location":"man/dev-index/#dev-index-types-2","page":"Internals","title":"Constants","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Pages   = [\"dev-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:constant]","category":"page"},{"location":"man/dev-index/#dev-index-docs","page":"Internals","title":"Docs","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Documentation for all internal names are listed below.","category":"page"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Modules = [ClusterValidityIndices]\nPublic = false","category":"page"},{"location":"man/dev-index/#ClusterValidityIndices.LabelMap","page":"Internals","title":"ClusterValidityIndices.LabelMap","text":"LabelMap\n\nDescription\n\nInternal label mapping for incremental CVIs.\n\nAlias for a dictionary mapping of integers to integers as cluster labels.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#ClusterValidityIndices.evaluate!-Tuple{CVI}","page":"Internals","title":"ClusterValidityIndices.evaluate!","text":"Summary\n\nCompute the criterion value of the CVI.\n\nAfter computation, the resulting criterion value can be extracted from cvi.criterion_value. The criterion value is a function of the CVI/ICVI internal parameters, so at least two classes (i.e., unique labels) must be presented to the CVI in param_inc! or param_batch! before a non-zero value is returned.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI to use for computing the criterion value.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_batch!(my_cvi, data, labels)\njulia> evaluate!(my_cvi)\njulia> my_criterion_value = my_cvi.criterion_value\n\nMethod List / Definition Locations\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:178.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:208.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:210.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:207.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:160.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:185.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:204.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:226.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:227.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#ClusterValidityIndices.get_internal_label!-Tuple{Dict{Int64, Int64}, Integer}","page":"Internals","title":"ClusterValidityIndices.get_internal_label!","text":"get_internal_label!(\n    label_map::Dict{Int64, Int64},\n    label::Integer\n) -> Integer\n\n\nSummary\n\nGet the internal label and update the label map if the label is new.\n\nArguments\n\nlabel_map::LabelMap: label map to extract the internal label from.\nlabel::Integer: the external label that corresponds to an internal label.\n\nMethod List / Definition Locations\n\nget_internal_label!(label_map, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/common.jl:163.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#ClusterValidityIndices.param_batch!-Tuple{CVI, AbstractMatrix{T} where T<:Real, AbstractVector{T} where T<:Integer}","page":"Internals","title":"ClusterValidityIndices.param_batch!","text":"Summary\n\nCompute the CVI parameters in batch.\n\nThis method updates only the internal parameters of the CVI algorithm in batch. When the criterion value itself is needed, use evaluate! and extract it from cvi.criterion_value.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI algorithm.\ndata::RealMatrix: a matrix of data where rows are features and columns are samples, used in the external clustering algorithm.\nlabels::IntegerVector: a vector of labels that the external clustering algorithm prescribed to each column in data.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_batch!(my_cvi, data, labels)\n\nMethod List / Definition Locations\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:157.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:179.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:182.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:179.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:138.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:164.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:175.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:200.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:181.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#ClusterValidityIndices.param_inc!-Tuple{CVI, AbstractVector{T} where T<:Real, Integer}","page":"Internals","title":"ClusterValidityIndices.param_inc!","text":"Summary\n\nCompute the CVI parameters incrementally.\n\nThis method updates only internal parameters of the ICVI algorithm incrementally. When the criterion value itself is needed, use evaluate! and extract it from cvi.criterion_value.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI algorithm.\nsample::RealVector: a vector of features used in the external clustering algorithm.\nlabel::Integer: the label that the external clustering algorithm prescribed to the sample.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_inc!(my_cvi, data[:, 1], labels[1])\n\nMethod List / Definition Locations\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:99.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:97.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:102.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:102.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:85.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:104.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:95.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:92.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:106.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#ClusterValidityIndices.setup!-Tuple{CVI, AbstractVector{T} where T<:Real}","page":"Internals","title":"ClusterValidityIndices.setup!","text":"Summary\n\nInternal method, sets up the CVI based upon the type of the provided sample.\n\nArguments\n\ncvi::CVI: the CVI to setup to the correct dimensions.\nsample::RealVector: The sample to use as a basis for setting up the CVI.\n\nMethod List / Definition Locations\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:89.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:86.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:92.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:92.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:77.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:94.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:86.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:82.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:92.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#main-index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This page lists the core methods and types of the ClusterValidityIndices.jl package. The Modules section lists the modules exported by the package including the ClusterValidityIndices module itself. The Methods section lists the public methods for the package that use the CVIs/ICVIs in Types. Each of these entries link to the docstrings in the Docs section.","category":"page"},{"location":"man/full-index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This section enumerates the names exported by the package, each of which links to its corresponding Documentation.","category":"page"},{"location":"man/full-index/#index-modules","page":"Index","title":"Modules","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:module]","category":"page"},{"location":"man/full-index/#index-methods","page":"Index","title":"Functions","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:function]","category":"page"},{"location":"man/full-index/#index-types","page":"Index","title":"Types","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:type]","category":"page"},{"location":"man/full-index/#index-constants","page":"Index","title":"Constants","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:constant]","category":"page"},{"location":"man/full-index/#index-docs","page":"Index","title":"Docs","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This section lists the documentation for every exported name of the ClusterValidityIndices.jl package.","category":"page"},{"location":"man/full-index/#Modules","page":"Index","title":"Modules","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]\nPrivate = false\nOrder = [:module]","category":"page"},{"location":"man/full-index/#ClusterValidityIndices.ClusterValidityIndices","page":"Index","title":"ClusterValidityIndices.ClusterValidityIndices","text":"Main module for ClusterValidityIndices.jl, a Julia package of metrics for unsupervised learning.\n\nThis module exports all of the CVI modules, options, and utilities used by the ClusterValidityIndices.jl package. For full usage, see the official guide at https://ap6yc.github.io/ClusterValidityIndices.jl/dev/man/guide/.\n\nBasic Usage\n\nInstall and import the package in a script with\n\nusing Pkg\nPkg.add(\"ClusterValidityIndices\")\nusing ClusterValidityIndices\n\nthen create a CVI object with an empty argument constructor\n\nmy_cvi = DB()\n\nand get the criterion values with get_cvi! (batch) or get_icvi! (incremental)\n\n# Load some features and labels from a clustering process\nfeatures, labels = get_some_clustering_data()\n\n# Batch criterion value\ncriterion_value = get_cvi!(my_cvi, features, labels)\n\n# Incremental criterion values\ncriterion_values = zeros(length(labels))\nfor ix in eachindex(labels)\n    criterion_values[ix] = get_icvi!(my_cvi, features[:, ix], labels[ix])\nend\n\nImports\n\nThe following names are imported by the package as dependencies:\n\nBase\nCore\nDocStringExtensions\nLinearAlgebra\nNumericalTypeAliases\nPkg\n\nExports\n\nThe following names are exported and available when using the package:\n\nCH\nCLUSTERVALIDITYINDICES_VERSION\nCVI\nCVI_MODULES\nDB\nGD43\nGD53\nPS\nWB\nXB\ncSIL\nget_cvi!\nrCIP\n\n\n\n\n\n","category":"module"},{"location":"man/full-index/#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"man/full-index/#ClusterValidityIndices.get_cvi!-Tuple{CVI, AbstractMatrix{T} where T<:Real, AbstractVector{T} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.get_cvi!","text":"get_cvi!(\n    cvi::CVI,\n    data::AbstractMatrix{T} where T<:Real,\n    labels::AbstractVector{T} where T<:Integer\n) -> Any\n\n\nSummary\n\nCompute and return the criterion value in batch mode.\n\nThis method takes the CVI object, a batch of samples as a matrix of floats, and a vector of integers that represent the labels prescribed to the data by your clustering algorithm.\n\nnote: Note\nYou cannot switch to incremental mode after evaluating a CVI in batch mode. To evaluate incrementally, you much create a new CVI object.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI providing the criterion value.\ndata::RealMatrix: a matrix of data, columns as samples and rows as features, used in the external clustering process.\nlabels::IntegerVector: a vector of integers representing labels prescribed to the data by the external clustering algorithm.\n\nExamples\n\n# Create a new CVI object\nmy_cvi = CH()\n\n# Load in random data as an example; 10 samples with feature dimenison 3\ndim = 3\nn_samples = 10\ndata = rand(dim, n_samples)\nlabels = repeat(1:2, inner=n_samples)\n\n# Compute the final criterion value in batch mode\ncriterion_value = get_cvi!(cvi, data, labels)\n\nMethod List / Definition Locations\n\nget_cvi!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/common.jl:145.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.get_cvi!-Tuple{CVI, AbstractVector{T} where T<:Real, Integer}","page":"Index","title":"ClusterValidityIndices.get_cvi!","text":"get_cvi!(\n    cvi::CVI,\n    sample::AbstractVector{T} where T<:Real,\n    label::Integer\n) -> Any\n\n\nSummary\n\nCompute and return the criterion value incrementally.\n\nThis method takes the CVI object, a single sample as a vector of floats, and a single integer that represents the label prescribed to the sample by your clustering algorithm.\n\nnote: Note\nYou cannot switch to batch mode after incrementally evaluating a CVI. To evaluate in batch, you much create a new CVI object.\n\nArguments\n\ncvi::CVI: the stateful information of the ICVI providing the criterion value.\nsample::RealVector: a vector of features used in clustering the sample.\nlabel::Integer: the cluster label prescribed to the sample by the clustering algorithm.\n\nExamples\n\n# Create a new CVI object\nmy_cvi = CH()\n\n# Load in random data as an example; 10 samples with feature dimenison 3\ndim = 3\nn_samples = 10\ndata = rand(dim, n_samples)\nlabels = repeat(1:2, inner=n_samples)\n\n# Iteratively compute and extract the criterion value at every step\ncriterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    sample = data[:, ix]\n    label = labels[ix]\n    criterion_values[ix] = get_icvi!(my_cvi, sample, label)\nend\n\nMethod List / Definition Locations\n\nget_cvi!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/common.jl:105.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"man/full-index/#ClusterValidityIndices.CH","page":"Index","title":"ClusterValidityIndices.CH","text":"mutable struct CH <: CVI\n\nSummary\n\nThe stateful information of the Calinski-Harabasz (CH) Cluster Validity Index\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nT. Calinski and J. Harabasz, \"A dendrite method for cluster analysis,\" Communications in Statistics, vol. 3, no. 1, pp. 1-27, 1974.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Int64\nn_samples::Int64\nmu::Vector{Float64}\nn::Vector{Int64}\nv::Matrix{Float64}\nCP::Vector{Float64}\nSEP::Vector{Float64}\nG::Matrix{Float64}\nBGSS::Float64\nWGSS::Float64\nn_clusters::Int64\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.CH-Tuple{}","page":"Index","title":"ClusterValidityIndices.CH","text":"CH() -> CH\n\n\nSummary\n\nConstructor for the Calinski-Harabasz (CH) Cluster Validity Index.\n\nExamples\n\n# Import the package\nusing ClusterValidityIndices\n# Construct a CH module\nmy_cvi = CH()\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nT. Calinski and J. Harabasz, \"A dendrite method for cluster analysis,\" Communications in Statistics, vol. 3, no. 1, pp. 1-27, 1974.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nMethod List / Definition Locations\n\nCH()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:70.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.CVI","page":"Index","title":"ClusterValidityIndices.CVI","text":"abstract type CVI\n\nSummary\n\nAbstract supertype for all CVI objects. All index instantiations are subtypes of CVI.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.DB","page":"Index","title":"ClusterValidityIndices.DB","text":"mutable struct DB <: CVI\n\nSummary\n\nThe stateful information of the Davies-Bouldin (DB) Cluster Validity Index.\n\nReferences\n\nD. L. Davies and D. W. Bouldin, \"A cluster separation measure,\" IEEE Transaction on Pattern Analysis and Machine Intelligence, vol. 1, no. 2, pp. 224-227, Feb. 1979.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Int64\nn_samples::Int64\nmu_data::Vector{Float64}\nn::Vector{Int64}\nv::Matrix{Float64}\nCP::Vector{Float64}\nS::Vector{Float64}\nR::Matrix{Float64}\nG::Matrix{Float64}\nD::Matrix{Float64}\nn_clusters::Int64\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.DB-Tuple{}","page":"Index","title":"ClusterValidityIndices.DB","text":"DB() -> DB\n\n\nSummary\n\nConstructor for the Davies-Bouldin (DB) Cluster Validity Index.\n\nExamples\n\n# Import the package\nusing ClusterValidityIndices\n# Construct a DB module\nmy_cvi = DB()\n\nReferences\n\nD. L. Davies and D. W. Bouldin, \"A cluster separation measure,\" IEEE Transaction on Pattern Analysis and Machine Intelligence, vol. 1, no. 2, pp. 224-227, Feb. 1979.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nMethod List / Definition Locations\n\nDB()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:67.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.GD43","page":"Index","title":"ClusterValidityIndices.GD43","text":"mutable struct GD43 <: CVI\n\nSummary\n\nThe stateful information of the Generalized Dunn's Index 43 (GD43) Cluster Validity Index.\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1-12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32-57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301-315, Jun. 1998.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Int64\nn_samples::Int64\nmu_data::Vector{Float64}\nn::Vector{Int64}\nv::Matrix{Float64}\nCP::Vector{Float64}\nG::Matrix{Float64}\nD::Matrix{Float64}\ninter::Float64\nintra::Float64\nn_clusters::Int64\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.GD43-Tuple{}","page":"Index","title":"ClusterValidityIndices.GD43","text":"GD43() -> GD43\n\n\nSummary\n\nConstructor for the Generalized Dunn's Index 43 (GD43) Cluster Validity Index.\n\nExamples\n\n# Import the package\nusing ClusterValidityIndices\n# Construct a GD43 module\nmy_cvi = GD43()\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1-12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32-57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301-315, Jun. 1998.\n\nMethod List / Definition Locations\n\nGD43()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:73.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.GD53","page":"Index","title":"ClusterValidityIndices.GD53","text":"mutable struct GD53 <: CVI\n\nSummary\n\nThe stateful information of the Generalized Dunn's Index 53 (GD53) Cluster Validity Index.\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1-12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32-57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301-315, Jun. 1998.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Int64\nn_samples::Int64\nmu_data::Vector{Float64}\nn::Vector{Int64}\nv::Matrix{Float64}\nCP::Vector{Float64}\nG::Matrix{Float64}\nD::Matrix{Float64}\ninter::Float64\nintra::Float64\nn_clusters::Int64\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.GD53-Tuple{}","page":"Index","title":"ClusterValidityIndices.GD53","text":"GD53() -> GD53\n\n\nSummary\n\nConstructor for the Generalized Dunn's Index 53 (GD53) Cluster Validity Index.\n\nExamples\n\n# Import the package\nusing ClusterValidityIndices\n# Construct a GD53 module\nmy_cvi = GD53()\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1-12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32-57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301-315, Jun. 1998.\n\nMethod List / Definition Locations\n\nGD53()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:73.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.PS","page":"Index","title":"ClusterValidityIndices.PS","text":"mutable struct PS <: CVI\n\nSummary\n\nThe stateful information of the Partition Separation (PS) Cluster Validity Index.\n\nReferences\n\nMiin-Shen Yang and Kuo-Lung Wu, \"A new validity index for fuzzy clustering,\" 10th IEEE International Conference on Fuzzy Systems. (Cat. No.01CH37297), Melbourne, Victoria, Australia, 2001, pp. 89-92, vol.1.\nE. Lughofer, \"Extensions of vector quantization for incremental clustering,\" Pattern Recognit., vol. 41, no. 3, pp. 995-1011, 2008.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Int64\nn_samples::Int64\nn::Vector{Int64}\nv::Matrix{Float64}\nD::Matrix{Float64}\nv_bar::Vector{Float64}\nbeta_t::Float64\nPS_i::Vector{Float64}\nn_clusters::Int64\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.PS-Tuple{}","page":"Index","title":"ClusterValidityIndices.PS","text":"PS() -> PS\n\n\nSummary\n\nConstructor for the Partition Separation (PS) Cluster Validity Index.\n\nExamples\n\n# Import the package\nusing ClusterValidityIndices\n# Construct a PS module\nmy_cvi = PS()\n\nReferences\n\nMiin-Shen Yang and Kuo-Lung Wu, \"A new validity index for fuzzy clustering,\" 10th IEEE International Conference on Fuzzy Systems. (Cat. No.01CH37297), Melbourne, Victoria, Australia, 2001, pp. 89-92, vol.1.\nE. Lughofer, \"Extensions of vector quantization for incremental clustering,\" Pattern Recognit., vol. 41, no. 3, pp. 995-1011, 2008.\n\nMethod List / Definition Locations\n\nPS()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:60.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.WB","page":"Index","title":"ClusterValidityIndices.WB","text":"mutable struct WB <: CVI\n\nSummary\n\nThe stateful information of the WB-Index (WB) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nQ. Zhao, M. Xu, and P. Franti, \"Sum-of-Squares Based Cluster Validity Index and Significance Analysis,\" in Adaptive and Natural Computing Algorithms, M. Kolehmainen, P. Toivanen, and B. Beliczynski, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009, pp. 313-322.\nQ. Zhao and P. Franti, \"WB-index: A sum-of-squares based index for cluster validity,\" Data Knowledge Engineering, vol. 92, pp. 77-89, 2014.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Int64\nn_samples::Int64\nmu::Vector{Float64}\nn::Vector{Int64}\nv::Matrix{Float64}\nCP::Vector{Float64}\nSEP::Vector{Float64}\nG::Matrix{Float64}\nBGSS::Float64\nWGSS::Float64\nn_clusters::Int64\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.WB-Tuple{}","page":"Index","title":"ClusterValidityIndices.WB","text":"WB() -> WB\n\n\nSummary\n\nConstructor for the WB-Index (WB) Cluster Validity Index.\n\nExamples\n\n# Import the package\nusing ClusterValidityIndices\n# Construct a WB module\nmy_cvi = WB()\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nQ. Zhao, M. Xu, and P. Franti, \"Sum-of-Squares Based Cluster Validity Index and Significance Analysis,\" in Adaptive and Natural Computing Algorithms, M. Kolehmainen, P. Toivanen, and B. Beliczynski, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009, pp. 313-322.\nQ. Zhao and P. Franti, \"WB-index: A sum-of-squares based index for cluster validity,\" Data Knowledge Engineering, vol. 92, pp. 77-89, 2014.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nMethod List / Definition Locations\n\nWB()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:75.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.XB","page":"Index","title":"ClusterValidityIndices.XB","text":"mutable struct XB <: CVI\n\nSummary\n\nThe stateful information of the Xie-Beni (XB) Cluster Validity Index.\n\nReferences\n\nX. L. Xie and G. Beni, \"A Validity Measure for Fuzzy Clustering,\" IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 13, no. 8, pp. 841-847, 1991.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Int64\nn_samples::Int64\nmu_data::Vector{Float64}\nn::Vector{Int64}\nv::Matrix{Float64}\nCP::Vector{Float64}\nSEP::Float64\nG::Matrix{Float64}\nD::Matrix{Float64}\nWGSS::Float64\nn_clusters::Int64\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.XB-Tuple{}","page":"Index","title":"ClusterValidityIndices.XB","text":"XB() -> XB\n\n\nSummary\n\nConstructor for the Xie-Beni (XB) Cluster Validity Index.\n\nExamples\n\n# Import the package\nusing ClusterValidityIndices\n# Construct a XB module\nmy_cvi = XB()\n\nReferences\n\nX. L. Xie and G. Beni, \"A Validity Measure for Fuzzy Clustering,\" IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 13, no. 8, pp. 841-847, 1991.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nMethod List / Definition Locations\n\nXB()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:67.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.cSIL","page":"Index","title":"ClusterValidityIndices.cSIL","text":"mutable struct cSIL <: CVI\n\nSummary\n\nThe stateful information of the Centroid-based Silhouette (cSIL) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nP. J. Rousseeuw, \"Silhouettes: A graphical aid to the interpretation and validation of cluster analysis,\" Journal of Computational and Applied Mathematics, vol. 20, pp. 53-65, 1987.\nM. Rawashdeh and A. Ralescu, \"Center-wise intra-inter silhouettes,\" in Scalable Uncertainty Management, E. Hüllermeier, S. Link, T. Fober et al., Eds. Berlin, Heidelberg: Springer, 2012, pp. 406-419.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Int64\nn_samples::Int64\nn::Vector{Int64}\nv::Matrix{Float64}\nCP::Vector{Float64}\nG::Matrix{Float64}\nS::Matrix{Float64}\nsil_coefs::Vector{Float64}\nn_clusters::Int64\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.cSIL-Tuple{}","page":"Index","title":"ClusterValidityIndices.cSIL","text":"cSIL() -> cSIL\n\n\nSummary\n\nConstructor for the Centroid-based Silhouette (cSIL) Cluster Validity Index.\n\nExamples\n\n# Import the package\nusing ClusterValidityIndices\n# Construct a cSIL module\nmy_cvi = cSIL()\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nP. J. Rousseeuw, \"Silhouettes: A graphical aid to the interpretation and validation of cluster analysis,\" Journal of Computational and Applied Mathematics, vol. 20, pp. 53-65, 1987.\nM. Rawashdeh and A. Ralescu, \"Center-wise intra-inter silhouettes,\" in Scalable Uncertainty Management, E. Hüllermeier, S. Link, T. Fober et al., Eds. Berlin, Heidelberg: Springer, 2012, pp. 406-419.\n\nMethod List / Definition Locations\n\ncSIL()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:65.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.rCIP","page":"Index","title":"ClusterValidityIndices.rCIP","text":"mutable struct rCIP <: CVI\n\nSummary\n\nThe stateful information of the (Renyi's) representative Cross Information Potential (rCIP) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nE. Gokcay and J. C. Principe, \"A new clustering evaluation function using Renyi's information potential,\" in Proc. Int. Conf. Acoust., Speech, Signal Process. (ICASSP), vol. 6. Jun. 2000, pp. 3490-3493.\nE. Gokcay and J. C. Principe, \"Information theoretic clustering,\" IEEE Trans. Pattern Anal. Mach. Intell., vol. 24, no. 2, pp. 158-171, Feb. 2002.\nD. Araújo, A. D. Neto, and A. Martins, \"Representative cross information potential clustering,\" Pattern Recognit. Lett., vol. 34, no. 16, pp. 2181-2191, Dec. 2013.\nD. Araújo, A. D. Neto, and A. Martins, \"Information-theoretic clustering: A representative and evolutionary approach,\" Expert Syst. Appl., vol. 40, no. 10, pp. 4190-4205, Aug. 2013.\nR. O. Duda, P. E. Hart, and D. G. Stork, Pattern Classification, 2nd ed. John Wiley & Sons, 2000.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Int64\nn_samples::Int64\nn::Vector{Int64}\nv::Matrix{Float64}\nsigma::Array{Float64, 3}\nconstant::Float64\nD::Matrix{Float64}\ndelta_term::Matrix{Float64}\nn_clusters::Int64\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.rCIP-Tuple{}","page":"Index","title":"ClusterValidityIndices.rCIP","text":"rCIP() -> rCIP\n\n\nSummary\n\nConstructor for the (Renyi's) representative Cross Information Potential (rCIP) Cluster Validity Index.\n\nExamples\n\n# Import the package\nusing ClusterValidityIndices\n# Construct a rCIP module\nmy_cvi = rCIP()\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nE. Gokcay and J. C. Principe, \"A new clustering evaluation function using Renyi's information potential,\" in Proc. Int. Conf. Acoust., Speech, Signal Process. (ICASSP), vol. 6. Jun. 2000, pp. 3490-3493.\nE. Gokcay and J. C. Principe, \"Information theoretic clustering,\" IEEE Trans. Pattern Anal. Mach. Intell., vol. 24, no. 2, pp. 158-171, Feb. 2002.\nD. Araújo, A. D. Neto, and A. Martins, \"Representative cross information potential clustering,\" Pattern Recognit. Lett., vol. 34, no. 16, pp. 2181-2191, Dec. 2013.\nD. Araújo, A. D. Neto, and A. Martins, \"Information-theoretic clustering: A representative and evolutionary approach,\" Expert Syst. Appl., vol. 40, no. 10, pp. 4190-4205, Aug. 2013.\nR. O. Duda, P. E. Hart, and D. G. Stork, Pattern Classification, 2nd ed. John Wiley & Sons, 2000.\n\nMethod List / Definition Locations\n\nrCIP()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:75.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#Constants","page":"Index","title":"Constants","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]\nPrivate = false\nOrder = [:constant]","category":"page"},{"location":"man/full-index/#ClusterValidityIndices.CLUSTERVALIDITYINDICES_VERSION","page":"Index","title":"ClusterValidityIndices.CLUSTERVALIDITYINDICES_VERSION","text":"CLUSTERVALIDITYINDICES_VERSION\n\nDescription\n\nA constant that contains the version of the installed ClusterValidityIndices.jl package.\n\nThis value is computed at compile time, so it may be used to programmatically verify the version of ClusterValidityIndices that is installed in case a compat entry in your Project.toml is missing or otherwise incorrect.\n\n\n\n\n\n","category":"constant"},{"location":"man/full-index/#ClusterValidityIndices.CVI_MODULES","page":"Index","title":"ClusterValidityIndices.CVI_MODULES","text":"CVI_MODULES\n\nDescription\n\nList of implemented CVIs, useful for iteration. Each element is the struct abbreviated name for the CVI, which can be instantiated for iteration with the empty constructor.\n\nFor example:\n\nusing ClusterValidityIndices\ninstantiated_cvis = [local_cvi() for local_cvi in CVI_MODULES]\n\n\n\n\n\n","category":"constant"},{"location":"","page":"Home","title":"Home","text":"(Image: header)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"These pages serve as the official documentation for the ClusterValidityIndices.jl Julia package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cluster Validity Indices (CVI) tackle the problem of judging the performance of an unsupervised/clustering algorithm without the availability of truth or supervisory labels, resulting in metrics of under- or over-partitioning. Furthermore, Incremental CVIs (ICVI) are variants of these ordinarily batch algorithms that enable an online and computationally tractable method of evaluating the performance of a clustering algorithm as it clusters while being numerically equivalent to their batch counterparts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is to provide a home for the development and use of these CVIs and ICVIs. For a list of all CVIs available from the package, see the Implemented CVI List page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation is split into the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"getting-started/what-are-cvis.md\",\n    \"getting-started/basic-example.md\",\n    \"man/guide.md\",\n    \"man/cvi-list.md\",\n    \"../examples/index.md\",\n    \"man/contributing.md\",\n    \"man/full-index.md\",\n    \"man/dev-index.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Background provides an overview of the problem statement of CVIs and what they are theoretically, while Basic Example steps through an single example workflow.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Package Guide provides a tutorial to the full usage of the package, while Examples gives many sample workflows using a variety of CVI modules. All CVIs in the package are listed in the Implemented CVI List page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instructions on how to contribute to the package are found in Contributing, and docstrings for every element of the package is listed in the Index. Names internal to the package are also listed under the Developer Index.","category":"page"}]
}
