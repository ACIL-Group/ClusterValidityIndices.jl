var documenterSearchIndex = {"docs":
[{"location":"examples/cvis/cvi-icvi/#cvi_icvi","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"(Image: Source code) (Image: notebook) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/cvis/cvi-icvi/#Overview","page":"CVI-ICVI Comparison","title":"Overview","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"This demo is a simple example of how to use CVIs incrementally and in batch to demonstrate that the end results are the same. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. In the incremental case, we will take advantage of the fact that we can compute a criterion value at every step by running the ICVI alongside an online clustering algorithm. This simple example demonstrates the usage of a single CVI/ICVI, but it may be substituted for any other CVI/ICVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/cvis/cvi-icvi/#Data-Setup","page":"CVI-ICVI Comparison","title":"Data Setup","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing DataFrames                # DataFrames, necessary for MLDatasets.Iris()\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"iris = Iris(as_df=false)\nfeatures, labels = iris.features, iris.targets","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:}","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"labels = convertlabel(LabelEnc.Indices{Int}, vec(labels))\nunique(labels)","category":"page"},{"location":"examples/cvis/cvi-icvi/#CVI/ICVI-Setup","page":"CVI-ICVI Comparison","title":"CVI/ICVI Setup","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Because CVI/ICVIs only differ in their evaluation mode, we will use the same default constructor for both of our objects. Here, we will use the same type of CVI for both objects to verify that the results of both are the same at the final iteration.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Create both CVI objects, using one incrementally as an ICVI\nicvi = CH()\ncvi = CH()","category":"page"},{"location":"examples/cvis/cvi-icvi/#Online-Clustering","page":"CVI-ICVI Comparison","title":"Online Clustering","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/#Adaptive-Resonance-Theory-Algorithms","page":"CVI-ICVI Comparison","title":"Adaptive Resonance Theory Algorithms","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Create a Distributed Dual-Vigilance Fuzzy ART (DDVFA) module with default options\nart = DDVFA()\ntypeof(art)","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Because we are streaming clustering, we must setup the internal data setup of the DDVFA module. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Setup the data configuration for the module\ndata_setup!(art.config, features)\n# Verify that the data is setup\nart.config.setup","category":"page"},{"location":"examples/cvis/cvi-icvi/#Iteration","page":"CVI-ICVI Comparison","title":"Iteration","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"We can now cluster and get the criterion values online We will do this by creating an ICVI object, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Setup the online/streaming clustering\nn_samples = length(labels)          # Number of samples\nc_labels = zeros(Int, n_samples)    # Clustering labels\ncriterion_values = zeros(n_samples) # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Cluster the sample online\n    c_labels[ix] = train!(art, sample)\n    # Get the new criterion value (ICVI output)\n    criterion_values[ix] = get_icvi!(icvi, sample, c_labels[ix])\nend\n\n# See the list of criterion values\ncriterion_values","category":"page"},{"location":"examples/cvis/cvi-icvi/#Batch-Evaluation","page":"CVI-ICVI Comparison","title":"Batch Evaluation","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"In batch mode, we will use the sample features and prescribed cluster labels as before to verify that the criterion values are the same at the last iteration.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Get the final criterion value in batch\nbatch_criterion_value = get_cvi!(cvi, features, c_labels)","category":"page"},{"location":"examples/cvis/cvi-icvi/#Comparison","page":"CVI-ICVI Comparison","title":"Comparison","text":"","category":"section"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"Now we check that the two produce the same results in the end.","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"# Print the batch result and the final result of the incremental variant\n@printf \"Batch criterion value: %.4f\\n\" batch_criterion_value\n@printf \"Final incremental criterion value: %.4f\\n\" criterion_values[end]","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"","category":"page"},{"location":"examples/cvis/cvi-icvi/","page":"CVI-ICVI Comparison","title":"CVI-ICVI Comparison","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"getting-started/basic-example/#Basic-Example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"This page gives a basic overview of a workflow using CVIs. For more detailed and interactive examples that you can run on your own in Julia notebooks, see the Examples section.","category":"page"},{"location":"getting-started/basic-example/#CVI-Full-Usage-Example","page":"Basic Example","title":"CVI Full Usage Example","text":"","category":"section"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"Consider that you already have a dataset that is labeled by some clustering algorithm. This is not strictly necessary in practice, as the incremental variants of each CVI are designed to be able to run online alongside a clustering process, but we do so here for simplicity. We treat the labels here as clustering-prescribed labels rather than true supervised labels, and we treat the data as the samples that were used to cluster to those labels.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"We begin by loading the module and loading the data wherever it may be:","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Load the CVI/ICVI module\nusing ClusterValidityIndices\n\n# Point to the data file\ndata_path = \"data/correct_partition.csv\"\n\n# Load the data and labels\ndata, labels = get_cvi_data(data_path)","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"Because Julia is column-major in memory and our data samples are potentially large, we follow the Julia notation and treat the dimensions of data as [dim, n_samples].","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"note: Note\nBefore ClusterValidityIndices.jl v0.3.0, all the CVIs assume that the labels are presented sequentially initially, starting with index 1 (e.g., 1, 1, 2, 2, 3, 2, 2, 1, 3, 4, 4 ...). You may repeat previously seen label indices, but skipping label indices (e.g., 1, 2, 4) results in undefined behavior. If your data does not accomodate this, we may circumvent this by relabelling the data monotonically withlabels = relabel_cvi_data(labels)","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"We can get the number of samples from the length of the labels vector because each data sample corresponds to a label:","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Get the number of samples for incremental iteration\nn_samples = length(labels)","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"We are now ready to instantiate our CVI with default parameters. Because we have incremental and batch variants, we will instantiate two CVI models, train one sequentially and one in batch, and show that their results are equivalent. We will use the Davies-Bouldin CVI/ICVI as an example here, but all CVIs in this package have the same usage.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Create two containers for the batch and incremental CVIs\ncvi_i = DB()\ncvi_b = DB()","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"We will preallocate an array for the criterion values of the incremental variant so that we can populate it iteratively.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Create some storage for our criterion values\ncriterion_values_i = zeros(n_samples)","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"We are now ready to evaluate the ICV incrementally, which we can to in one of two ways. Most simply, we can use get_icvi! function to evaluate the ICVI and return the criterion value all at once.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Iterate across all samples\nfor ix = 1:n_samples\n    # Update the CVI parameters and extract the criterion value in one function\n    criterion_values_i[ix] = get_icvi!(cvi_i, data[:, ix], labels[ix])\nend","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"If you desire more granularity, you can separately update the internal parameters of the CVI, evaluate those internal parameters into a criterion value, and extract that criterion value from the CVI.","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Iterate across all of the samples\nfor ix = ProgressBar(1:n_samples)\n    # Update the CVI internal parameters incrementally\n    param_inc!(cvi_i, data[:, ix], labels[ix])\n    # Evaluate the CVI to internally store the criterion value\n    evaluate!(cvi_i)\n    # Extract and save the criterion value at each step\n    criterion_values_i[ix] = cvi_i.criterion_value\nend","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"If we wish to do all of this in batch, we have methods that correspond to their incremental counterparts at a high level:","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Update and extract the criterion value all at once\ncriterion_value_b = get_cvi!(cvi_b, data, labels)","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"and at a more granular level:","category":"page"},{"location":"getting-started/basic-example/","page":"Basic Example","title":"Basic Example","text":"# Compute the parameters in batch\nparam_batch!(cvi_b, data, labels)\n\n# Evaluate the CVI criterion value\nevaluate!(cvi_b)\n\n# Extract the criterion value\ncriterion_value = cvi_b.criterion_value","category":"page"},{"location":"man/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"This page serves as the contribution guide for the ClusterValidityIndices.jl package. From top to bottom, the ways of contributing are:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"GitHub Issues: how to raise an issue with the project.\nJulia Development: how to download and interact with the package.\nGitFlow: how to directly contribute code to the package in an organized way on GitHub.\nDevelopment Details: how the internals of the package are currently setup if you would like to directly contribute code.","category":"page"},{"location":"man/contributing/#Issues","page":"Contributing","title":"Issues","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The main point of contact is the GitHub issues page for the project. This is the easiest way to contribute to the project, as any issue you find or request you have will be addressed there by the authors of the package. Depending on the issue, the authors will collaborate with you, and after making changes they will link a pull request which addresses your concern or implements your proposed changes.","category":"page"},{"location":"man/contributing/#Julia-Development","page":"Contributing","title":"Julia Development","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"As a Julia package, development follows the usual procedure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Clone the project from GitHub\nSwitch to or create the branch that you wish work on (see GitFlow).\nStart Julia at your development folder.\nInstantiate the package (i.e., download and install the package dependencies).","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"For example, you can get the package and startup Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"git clone git@github.com:AP6YC/ClusterValidityIndices.jl.git\njulia --project=.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIn Julia, you must activate your project in the current REPL to point to the location/scope of installed packages. The above immediately activates the project when starting up Julia, but you may also separately startup the julia and activate the package with the interactive package manager via the ] syntax:julia> ]\n(@v1.8) pkg> activate .\n(ClusterValidityIndices) pkg>","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"You may run the package's unit tests after the above setup in Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> using Pkg\njulia> Pkg.instantiate()\njulia> Pkg.test()","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"or interactively though the Julia package manager with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> ]\n(ClusterValidityIndices) pkg> instantiate\n(ClusterValidityIndices) pkg> test","category":"page"},{"location":"man/contributing/#GitFlow","page":"Contributing","title":"GitFlow","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"As of verson 0.3.1, the ClusterValidityIndices.jl package follows the GitFlow git working model. The original post by Vincent Driessen outlines this methodology quite well, while Atlassian has a good tutorial as well. In summary:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Create a feature branch off of the develop branch with the name feature/<my-feature-name>.\nCommit your changes and push to this feature branch.\nWhen you are satisfied with your changes, initiate a GitHub pull request (PR) to merge the feature branch with develop.\nIf the unit tests pass, the feature branch will first be merged with develop and then be deleted.\nReleases will be periodically initiated from the develop branch and versioned onto the master branch.\nImmediate bug fixes circumvent this process through a hotfix branch off of master.","category":"page"},{"location":"man/contributing/#Development-Details","page":"Contributing","title":"Development Details","text":"","category":"section"},{"location":"man/contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"These docs are currently hosted as a static site on the GitHub pages platform. They are setup to be built and served in a separate branch gh-pages from the master/development branch of the project.","category":"page"},{"location":"man/contributing/#Package-Structure","page":"Contributing","title":"Package Structure","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The ClusterValidityIndices.jl package has the following file structure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"ClusterValidityIndices.jl\n├── .github/workflows       // GitHub: workflows for testing and documentation.\n├── data                    // Data: CI and example data location.\n├── docs                    // Docs: GitHub pages documentation files.\n├── paper                   // Docs: JOSS paper and bib files.\n├── src                     // Source: scripts and common helper functions.\n│   └─── CVI                //      All CVI and ICVI definitions\n├── test                    // Test: unit, integration, and environment tests.\n├── .appveyor               // CI: Appveyor CI script\n├── .gitignore              // Git: .gitignore for the whole project.\n├── CODE_OF_CONDUCT         // Doc: the expectations of contributors to the project.\n├── CONTRIBUTING            // Doc: a summary of contribution guidelines, pointing to these docs.\n├── LICENSE                 // Doc: the license to the project.\n├── Manifest.toml           // Julia: the explicit package versions used (ignored).\n├── Project.toml            // Julia: the Pkg.jl dependencies of the project.\n└── README.md               // Doc: the README.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"All CVIs are implemented in separate files in the src/CVI/ directory, and they are imported to src/ClusterValidityIndices.jl through imports in src/CVI/CVI.jl.","category":"page"},{"location":"man/contributing/#CVI-Module-Workflow","page":"Contributing","title":"CVI Module Workflow","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"To write a CVI for this project, it will require the following:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"A struct subtyped from CVI that implements the internal parameters in addition to a Float named criterion_value and a LabelMap.\nA default constructor that initializes values to zeros and arrays to empties (see existing CVI files such as DB.jl for examples).\nAn incremental parameter update method param_inc!(cvi::NEW_CVI, sample::RealVector, label::Integer) where NEW_CVI is the name of the new CVI.\nA batch parameter update method param_batch!(cvi::NEW_CVI, data::RealMatrix, labels::IntegerVector).\nA criterion value evaluation method evaluate(cvi::NEW_CVI) that updates the internal criterion value.\nThe top-level functions get_icvi and get_cvi will work automatically after writing the above definitions!","category":"page"},{"location":"man/contributing/#Authors","page":"Contributing","title":"Authors","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"If you simply have suggestions for improvement, Sasha Petrenko (<sap625@mst.edu>) is the current developer and maintainer of the ClusterValidityIndices.jl package, so please feel free to reach out with thoughts and questions.","category":"page"},{"location":"man/guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"man/guide/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI package can be installed using the Julia package manager. From the Julia REPL, type ']' to enter the Pkg REPL mode and run","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"pkg> add CVI","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Alternatively, it can be added to your environment in a script with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"using Pkg\nPkg.add(\"ClusterValidityIndices\")","category":"page"},{"location":"man/guide/#Quickstart","page":"Guide","title":"Quickstart","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"This section provides a quick overview of how to use the project. For more detailed code usage, please see Usage. For a variety of detailed examples that you can run yourself, please see the Examples page.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"First, assume that you have a dataset of features/data and labels prescribed by some clustering algorithm:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"data_file = \"path/to/data.csv\"\ndata, labels = get_cvi_data(data_file)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"All CVI objects in this package are acronymed versions of their full names, which can be found in the Index. You can create a new CVI structure with a default constructor:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Davies-Bouldin (DB)\nmy_cvi = DB()","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The output of CVIs are called criterion values, and they can be computed incrementally with get_icvi","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"n_samples = length(labels)\ncriterion_values = zeros(n_samples)\nfor i = 1:n_samples\n    criterion_values[i] = get_icvi(data[:, i], labels[i])\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or in batch with get_cvi","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_value = get_cvi(data, labels)","category":"page"},{"location":"man/guide/#usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The usage of these CVIs requires an understanding of:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Data assumptions of the CVIs.\nHow to instantiate the CVIs.\nIncremental vs. batch evaluation.\nUpdating internal CVI parameters.\nComputing and extracting the criterion values.\nPorcelain functions that are available to simplify operation.","category":"page"},{"location":"man/guide/#data","page":"Guide","title":"Data","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Because Julia is programmed in a column-major fashion, all CVIs make the assumption that the first dimension (columns) contains features, while the second dimension (rows) contains samples. This is more important for batch operation, as incremental operation accepts 1-D sample of features at each time step by definition.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example,","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Load data from somewhere\ndata = load_data()\n# The data shape is dimsion x samples\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nAs of ClusterValidityIndices.jl v0.1.3, all the CVIs assume that the labels are presented sequentially initially, starting with index 1 (e.g., 1, 1, 2, 2, 3, 2, 2, 1, 3, 4, 4 ...). You may repeat previously seen label indices, but skipping label indices (e.g., 1, 2, 4) results in undefined behavior.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"In this project, this is ameliorated with the function","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"relabel_cvi_data(labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example,","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"data_file = \"path/to/data.csv\"\ndata, labels = get_cvi_data(data_file)\nlabels = relabel_cvi_data(labels)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Alternatively, you may pairwise sort the entirety of the data with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"sort_cvi_data(data::RealMatrix, labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nsort_cvi_data reorders the input data as well, which will lead to different ICVI results than with relabel_cvi_data.","category":"page"},{"location":"man/guide/#instantiation","page":"Guide","title":"Instantiation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The names of each CVI are capital abbreviations of their literature names, often based upon the surname of the principal authors of the papers that introduce the metrics. All CVIs are implemented with the default constructor, such as","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cvi = DB()","category":"page"},{"location":"man/guide/#inc-batch","page":"Guide","title":"Incremental vs. Batch","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVIs in this project all contain incremental and batch implementations. When evaluated in incremental mode, they are often called ICVIs (incremental cluster validity indices). In this documentation, CVI means batch and ICVI means incremental, though both are CVI objects.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The funtions that differ between the two modes are how they are updated:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nparam_inc!(cvi::CVI, sample::RealVector, label::Integer)\n# Batch\nparam_batch!(cvi::CVI, data::RealMatrix, labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"After updating their internal parameters, they both compute their most recent criterion values with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"evaluate!(cvi::CVI)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"To simplify the process, both modes have their respective \"porcelain\" functions to update the internal parameters, evaluate the criterion value, and return it:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nget_icvi!(cvi::CVI, sample::RealVector, label::Integer)\n# Batch\nget_cvi!(cvi::CVI, data::RealMatrix, labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nAny CVI object can be updated incrementally or in batch, as the CVIs are equivalent to their ICVI counterparts after all data is presented.","category":"page"},{"location":"man/guide/#updating","page":"Guide","title":"Updating","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVIs in this project all contain internal parameters that must be updated. Each update function modifies the CVI, so they use the Julia nomenclature convention of appending an exclamation point to indicate as much.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"In both incremental and batch modes, the parameter update requires:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI being updates\nThe sample (or array of samples)\nThe label(s) that was/were prescribed by the clustering algorithm to the sample(s)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"More concretely, they are","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental updating\nparam_inc!(cvi::CVI, sample::RealVector, label::Integer)\n# Batch updating\nparam_batch!(cvi::CVI, data::RealMatrix, labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Every CVI is a subtype of the abstract type CVI. For example, we may instantiate and load our data","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cvi = DB()\ndata = load_data()\nlabels = get_cluster_labels(data)\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"then update the parameters incrementally with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Iterate over all samples\nfor ix = 1:n_samples\n    sample = data[:, ix]\n    label = labels[ix]\n    param_inc!(cvi, sample, labels)\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or in batch with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"param_batch!(cvi, data, labels)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Furthermore, any CVI can alternate between being updated in incremental or batch modes, such as","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Create a new CVI\ncvi_mixed = DB()\n\n# Update on half of the data incrementally\ni_split = n_samples/2\nfor ix = 1:i_split\n    param_inc!(cvi, data[:, ix], labels[ix])\nend\n\n# Update on the other half all at once\nparam_batch!(cvi, data[:, (i_split+1):end])","category":"page"},{"location":"man/guide/#criterion-values","page":"Guide","title":"Criterion Values","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI parameters are separate from the criterion values that they produce. This is partly because in batch mode computing the criterion value is only relevant at the last step, which eliminates unnecessarily computing it at every step. This is also provide granularity to the user that may only which to extract the criterion value occasionally during incremental mode.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Because the criterion values only depend on the internal CVI parameters, they are computed (and internally stored) with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"evaluate!(cvi::C) where {C<:CVI}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"To extract them, you must then simply grab the criterion value from the CVI struct with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_value = cvi.criterion_value","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, after loading the data","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cvi = DB()\ndata = load_data()\nlabels = get_cluster_labels(data)\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"we may extract and return the criterion value at every step with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    param_inc!(cvi, data[:, ix], labels[ix])\n    evaluate!(cvi)\n    criterion_values[ix] = cvi.criterion_value\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or we may get it at the end in batch mode with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"param_batch!(cvi, data, labels)\nevaluate!(cvi)\ncriterion_value = cvi.criterion_value","category":"page"},{"location":"man/guide/#porcelain","page":"Guide","title":"Porcelain","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Taken from the git convention of calling low-level operations plumbing and high-level user-land functions porcelain, the package comes with a small set of porcelain function that do common operations all at once for the user.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, you may compute, evalute, and return the criterion value all at once with the functions","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nget_icvi!(...)\n# Batch\nget_cvi!(...)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Exactly as in the usage for updating the parameters, the functions take the cvi, sample(s), and clustered label(s) as input:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nget_icvi!(cvi::CVI, sample::RealVector, label::Integer)\n# Batch\nget_cvi!(cvi::CVI, data::RealMatrix, labels::IntegerVector)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, after loading the data you may get the criterion value at each step with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    criterion_values[ix] = get_icvi!(cvi, data[:, ix], labels[ix])\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or you may get the final criterion value in batch mode with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_value = get_cvi!(cvi, data, labels)","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section contains some examples using the ClusterValidityIndices.jl package with topics ranging from how to the internals of package work to practical examples on different datasets.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Basic-CVI/ICVI-Examples","page":"Examples","title":"Basic CVI/ICVI Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples demonstrate basic usage of the ClusterValidityIndices.jl package, such as how to run CVIs incrementally and in batch.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"grid-card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo is a simple example of how to use a CVI in batch mode.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CVI Simple Example","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo is a simple example of how to use a CVI in batch mode.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ICVI Simple Example","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/#Advanced-CVI/ICVI-Examples","page":"Examples","title":"Advanced CVI/ICVI Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples demonstrate some more advanced ins-and-outs of the ClusterValidityIndices.jl package, such as how various ICVIs compare to one another.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"grid-card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo illustrates how to use incremental training methods vs. batch training for all ART modules. This demo also demonstrates how the final results of each CVI and ICVI are equivalent.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CVI-ICVI Comparison","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo illustrates the differing behavior of each ICVI.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multi-ICVI Comparisons","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/basic-examples/icvi-example/#icvi_example","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"(Image: Source code) (Image: notebook) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/basic-examples/icvi-example/#Overview","page":"ICVI Simple Example","title":"Overview","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"This demo is a simple example of how to use CVIs incrementally. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. We will take advantage of the fact that we can compute a criterion value at every step by running the ICVI alongside an online clustering algorithm. This simple example demonstrates the usage of a single ICVI, but it may be substituted for any other ICVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/basic-examples/icvi-example/#Online-Clustering","page":"ICVI Simple Example","title":"Online Clustering","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/#Data-Setup","page":"ICVI Simple Example","title":"Data Setup","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing DataFrames                # DataFrames, necessary for MLDatasets.Iris()\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"iris = Iris(as_df=false)\nfeatures, labels = iris.features, iris.targets","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:}","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"labels = convertlabel(LabelEnc.Indices{Int}, vec(labels))\nunique(labels)","category":"page"},{"location":"examples/basic-examples/icvi-example/#ART-Online-Clustering","page":"ICVI Simple Example","title":"ART Online Clustering","text":"","category":"section"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"# Create a Distributed Dual-Vigilance Fuzzy ART (DDVFA) module with default options\nart = DDVFA()\ntypeof(art)","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"Because we are streaming clustering, we must setup the internal data setup of the DDVFA module. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"# Setup the data configuration for the module\ndata_setup!(art.config, features)\n# Verify that the data is setup\nart.config.setup","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"We can now cluster and get the criterion values online. We will do this by creating an ICVI object, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"# Create an ICVI object\nicvi = CH()\n\n# Setup the online/streaming clustering\nn_samples = length(labels)          # Number of samples\nc_labels = zeros(Int, n_samples)    # Clustering labels\ncriterion_values = zeros(n_samples) # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Cluster the sample online\n    c_labels[ix] = train!(art, sample)\n    # Get the new criterion value (ICVI output)\n    criterion_values[ix] = get_icvi!(icvi, sample, c_labels[ix])\nend\n\n# See the list of criterion values\ncriterion_values","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"","category":"page"},{"location":"examples/basic-examples/icvi-example/","page":"ICVI Simple Example","title":"ICVI Simple Example","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/cvis/icvi-comparison/#icvi_comparison","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"(Image: Source code) (Image: notebook) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/cvis/icvi-comparison/#Overview","page":"Multi-ICVI Comparisons","title":"Overview","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"This demo demostrates the differing behavior of the various ICVIs implemented in ClusterValidityIndices.jl. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. We will take advantage of the fact that we can compute a criterion value at every step by running the ICVI alongside an online clustering algorithm.","category":"page"},{"location":"examples/cvis/icvi-comparison/#Online-Clustering","page":"Multi-ICVI Comparisons","title":"Online Clustering","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/#Data-Setup","page":"Multi-ICVI Comparisons","title":"Data Setup","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"using ClusterValidityIndices    # CVI/ICVI\nusing AdaptiveResonance         # DDVFA\nusing MLDatasets                # Iris dataset\nusing DataFrames                # DataFrames, necessary for MLDatasets.Iris()\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing\nusing Plots                     # Plots frontend\ngr()                            # Use the default GR backend explicitly","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"iris = Iris(as_df=false)\nfeatures, labels = iris.features, iris.targets","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:}","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"labels = convertlabel(LabelEnc.Indices{Int}, vec(labels))\nunique(labels)","category":"page"},{"location":"examples/cvis/icvi-comparison/#ART-Online-Clustering","page":"Multi-ICVI Comparisons","title":"ART Online Clustering","text":"","category":"section"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Adaptive Resonance Theory (ART) is a neurocognitive theory that is the basis of a class of online clustering algorithms. Because these clustering algorithms run online, we can both cluster and compute a new criterion value at every step. For more on these ART algorithms, see AdaptiveResonance.jl.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Create a Distributed Dual-Vigilance Fuzzy ART (DDVFA) module with default options\nart = DDVFA()\ntypeof(art)","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Because we are streaming clustering, we must setup the internal data setup of the DDVFA module. This is akin to doing some data preprocessing and communicating the dimension of the data, bounds, etc. to the module beforehand.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Setup the data configuration for the module\ndata_setup!(art.config, features)\n# Verify that the data is setup\nart.config.setup","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We can now cluster and get the criterion values online. We will do this by creating many ICVI objects, setting up containers for the iterations, and then iterating.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Create many ICVI objects\nicvis = [\n    CH(),\n    cSIL(),\n    DB(),\n    GD43(),\n    GD53(),\n    PS(),\n    rCIP(),\n    WB(),\n    XB(),\n]\n\n# Setup the online/streaming clustering\nn_samples = length(labels)          # Number of samples\nn_icvi = length(icvis)              # Number of ICVIs being computed\nc_labels = zeros(Int, n_samples)    # Clustering labels\ncriterion_values = zeros(n_icvi, n_samples) # ICVI outputs\n\n# Iterate over all samples\nfor ix = 1:n_samples\n    # Extract one sample\n    sample = features[:, ix]\n    # Cluster the sample online\n    c_labels[ix] = train!(art, sample)\n    # Get the new criterion values (ICVI output)\n    for jx = 1:n_icvi\n        criterion_values[jx, ix] = get_icvi!(icvis[jx], sample, c_labels[ix])\n    end\nend\n\n# See the matrix of criterion values\ncriterion_values","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We can inspect the final ICVI values to see how they differ:","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"criterion_values[:, end]","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"Next, we would like to visualize these CVI trendlines over time with some plotting. We can try plotting these trendlines all over one another","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Define a simple function for plotting\nfunction plot_cvis(range)\n    # Create the plotting object\n    p = plot(legend=:topleft)\n    # Iterate over the range of ICVI indices provided\n    for jx = range\n        # Plot the ICVI criterion values versus sample index\n        plot!(p, 1:n_samples, criterion_values[jx, :], label = string(typeof(icvis[jx])))\n    end\n    # Return the plotting object for IJulia display\n    return p\nend\n\n# Plot all of the ICVIs tested here\nplot_cvis(1:n_icvi)","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"We see from the final values that the CH and cSIL metrics behave very differently from the other metrics, so we should plot them separately to see them in better detail.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"# Exclude CH and cSIL\nplot_cvis(3:n_icvi)","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"This plot shows that the icvis all have unique behaviors as the clustering process continues incrementally.","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"png(\"assets/icvi-comparision\") #hide","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"","category":"page"},{"location":"examples/cvis/icvi-comparison/","page":"Multi-ICVI Comparisons","title":"Multi-ICVI Comparisons","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/basic-examples/cvi-example/#cvi_example","page":"CVI Simple Example","title":"CVI Simple Example","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"(Image: Source code) (Image: notebook) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/basic-examples/cvi-example/#Overview","page":"CVI Simple Example","title":"Overview","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"This demo is a simple example of how to use CVIs in batch mode. Here, we load a simple dataset and run a basic clustering algorithm to prescribe a set of clusters to the features. It is a combination of these features and the prescribed labels that are used to compute the criterion value. This simple example demonstrates the usage of a single CVI, but it may be substituted for any other CVI in the ClusterValidityIndices.jl package.","category":"page"},{"location":"examples/basic-examples/cvi-example/#Clustering","page":"CVI Simple Example","title":"Clustering","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/#Data-Setup","page":"CVI Simple Example","title":"Data Setup","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"First, we must load all of our dependencies. We will load the ClusterValidityIndices.jl along with some data utilities and the Julia Clustering.jl package to cluster that data.","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"using ClusterValidityIndices    # CVI/ICVI\nusing Clustering                # DBSCAN\nusing MLDatasets                # Iris dataset\nusing DataFrames                # DataFrames, necessary for MLDatasets.Iris()\nusing MLDataUtils               # Shuffling and splitting\nusing Printf                    # Formatted number printing","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"iris = Iris(as_df=false)\nfeatures, labels = iris.features, iris.targets","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Because the MLDatasets package gives us Iris labels as strings, we will use the MLDataUtils.convertlabel method with the MLLabelUtils.LabelEnc.Indices type to get a list of integers representing each class:}","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"labels = convertlabel(LabelEnc.Indices{Int}, vec(labels))\nunique(labels)","category":"page"},{"location":"examples/basic-examples/cvi-example/#Fuzzy-C-Means","page":"CVI Simple Example","title":"Fuzzy C-Means","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Get the Fuzzy C-Means clustering result","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"results = fuzzy_cmeans(features, 3, 2)","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Because the results are fuzzy weights, find the maximum elements along each sample","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"indices = argmax(results.weights, dims=2)","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Get those labels as a vector of integers","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"c_labels = vec([c[2] for c in indices])","category":"page"},{"location":"examples/basic-examples/cvi-example/#CVI-Criterion-Value-Extraction","page":"CVI Simple Example","title":"CVI Criterion Value Extraction","text":"","category":"section"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Now that we have some data and a clustering algorithm's prescribed labels, we can compute a criterion value using a CVI in batch mode. First, we create a CVI object with the default constructor:","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"# Create a CVI object\nmy_cvi = CH()","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"Finally we can simply get the criterion value in batch by passing all of the data and Fuzzy C-Means labels at once.","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"# Get the batch criterion value\ncriterion_value = get_cvi!(my_cvi, features, c_labels)","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"","category":"page"},{"location":"examples/basic-examples/cvi-example/","page":"CVI Simple Example","title":"CVI Simple Example","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"getting-started/what-are-cvis/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"This page provides a theoretical overview of cluster validity indices and what this project aims to accomplish.","category":"page"},{"location":"getting-started/what-are-cvis/#Problem-Statement","page":"Background","title":"Problem Statement","text":"","category":"section"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Consider the following: say that you have an unlabeled dataset filled with vectors of features but no predefined \"bins\" that you could organize these sampels into. The desired end result is both a statement of how many bins of samples you have and a vector of labels corresponding to each sample prescribing which bin that sample belongs to. Both of these statements are generally equivalent beyond some edge cases, but it is worth noting the distinction.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"In this case, the realms of machine learning and statistics have the answer for you: clustering! So you do your research, select a suitable clustering algorithm for your dataset, program the algorithm, and retrieve a set of labels/bins for your dataset. What you've done is no small feat, built as it is upon the shoulders of giants. However, here comes the rub: how do you know how good your resulting bins are? Do these categories accurately reflect some underlying structure to the data, or are they no better than choosing random labels for each sample?","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Your first test may be to use another clustering algorithm, and then another. It is wise to check your answer against multiple other clustering algorithms because you don't want to put all of your eggs in one basket; though all clustering algorithms have different formulations that might give different results, they should all converge to the same sort of answer if the answer is correct in any way, shouldn't they? Sometimes they do, but usually they don't; different ways of binning things together result in different biases of structure.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"If the algorithms all give different answers, then which one is correct? If they're all different, can any one of them even be considered correct in the first place? The answer, sadly, is no. By definition, we cannot know if our answer is correct if we do not have the \"true\" labels for the data, if they even exist in the first place.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Since we can't create a true performance metric to compare how our clustering algorithms do on our dataset, we must find a way to create metrics that somehow give us a number based upon the structural behavior of the clustering algorithm. Enter cluster validity indices.","category":"page"},{"location":"getting-started/what-are-cvis/#What-are-Cluster-Validity-Indices?","page":"Background","title":"What are Cluster Validity Indices?","text":"","category":"section"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Cluster Validity Indices (CVIs) are designed to tackle the problem of creating a metric of performance for unsupervised algorithms where the true answer is unknown. Clustering is a ubiquitous unsupervised learning paradigm, so the terminology and development of CVIs principally target clustering algorithms.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"Because the clustering problem statement means that we do not have true labels to measure how well or poorly these algorithms perform, the most that we can do is to create a metric of the validity of the solution. This typically translates to how much an algorithm over- or under-partitions the data (i.e., how eager or reticent it is to create new categories), but some CVIs take other aspects of the structure of the solution into account, such as compactness (i.e., the density of the prescribed cluster regions) and connectedness (i.e., a measure of how much disparate points in a cluster can be said to still belong to the same category).","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"In general, CVIs take a set of samples and the labels prescribed to them by a clustering algorithm, and they return a criterion value that is generally a positive real number. This criterion value often does not have an upper bound, varies greatly in behavior between CVIs, and changes as new samples are labeled and the CVI is reprocessed. In fact, it is often the trendlines of these values that provide the most information about the clustering process rather than the values themselves.","category":"page"},{"location":"getting-started/what-are-cvis/","page":"Background","title":"Background","text":"CVIs are originally derived to work on batches of samples and labels. However, there exist incremental variants that are proven to be mathematically equivalent to their batch counterparts. These incremental CVIs (ICVIs) mitigate the computational overhead of computing these metrics online, such as in a streaming clustering scenarios.","category":"page"},{"location":"man/dev-index/#dev-main-index","page":"Internals","title":"Developer Index","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"This page lists the types and functions that are internal to the ClusterValidityIndices.jl package. Because they are not part of the public API, these names might change relatively frequently between versions and so should not be relied upon.","category":"page"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"All internal names are listed in the Index, and each of these entries link to the docstrings in the Docs section.","category":"page"},{"location":"man/dev-index/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"This section contains a list of internal names that link to their corresponding Documentation.","category":"page"},{"location":"man/dev-index/#dev-index-methods","page":"Internals","title":"Methods","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Pages   = [\"dev-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:function]","category":"page"},{"location":"man/dev-index/#dev-index-types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Pages   = [\"dev-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:type]","category":"page"},{"location":"man/dev-index/#dev-index-types-2","page":"Internals","title":"Constants","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Pages   = [\"dev-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:constant]","category":"page"},{"location":"man/dev-index/#dev-index-docs","page":"Internals","title":"Docs","text":"","category":"section"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Documentation for all internal names are listed below.","category":"page"},{"location":"man/dev-index/","page":"Internals","title":"Internals","text":"Modules = [ClusterValidityIndices]\nPublic = false","category":"page"},{"location":"man/dev-index/#ClusterValidityIndices.LabelMap","page":"Internals","title":"ClusterValidityIndices.LabelMap","text":"Internal label mapping for incremental CVIs.\n\nAlias for a dictionary mapping of integers to integers as cluster labels.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#ClusterValidityIndices.get_internal_label!-Tuple{Dict{Int64, Int64}, Int64}","page":"Internals","title":"ClusterValidityIndices.get_internal_label!","text":"get_internal_label!(label_map, label)\n\n\nSummary\n\nget_internal_label!(label_map::Dict{Int64, Int64}, label::Int64) -> Int64\n\n\nGet the internal label and update the label map if the label is new.\n\nArguments\n\nlabel_map::LabelMap: label map to extract the internal label from.\nlabel::Int: the external label that corresponds to an internal label.\n\nMethod List / Definition Locations\n\nget_internal_label!(label_map, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/common.jl:165.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{CVI, Vector{T}}} where T<:Union{Float32, Float64}","page":"Internals","title":"ClusterValidityIndices.setup!","text":"Summary\n\nInternal method, sets up the CVI based upon the type of the provided sample.\n\nArguments\n\ncvi::CVI: the CVI to setup to the correct dimensions.\nsample::Vector{T<:RealFP}: The sample to use as a basis for setting up the CVI.\n\nMethod List / Definition Locations\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:79.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:76.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:82.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:82.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:67.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:84.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:76.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:72.\n\nsetup!(cvi, sample)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:82.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#main-index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This page lists the core methods and types of the ClusterValidityIndices.jl package. The Modules section lists the modules exported by the package including the ClusterValidityIndices module itself. The Methods section lists the public methods for the package that use the CVIs/ICVIs in Types. Each of these entries link to the docstrings in the Docs section.","category":"page"},{"location":"man/full-index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This section enumerates the names exported by the package, each of which links to its corresponding Documentation.","category":"page"},{"location":"man/full-index/#index-modules","page":"Index","title":"Modules","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:module]","category":"page"},{"location":"man/full-index/#index-methods","page":"Index","title":"Functions","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:function]","category":"page"},{"location":"man/full-index/#index-types","page":"Index","title":"Types","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [ClusterValidityIndices]\nOrder = [:type]","category":"page"},{"location":"man/full-index/#index-docs","page":"Index","title":"Docs","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This section lists the documentation for every exported name of the ClusterValidityIndices.jl package.","category":"page"},{"location":"man/full-index/#Modules","page":"Index","title":"Modules","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]\nPrivate = false\nOrder = [:module]","category":"page"},{"location":"man/full-index/#ClusterValidityIndices.ClusterValidityIndices","page":"Index","title":"ClusterValidityIndices.ClusterValidityIndices","text":"Main module for ClusterValidityIndices.jl, a Julia package of metrics for unsupervised learning.\n\nThis module exports all of the CVI modules, options, and utilities used by the ClusterValidityIndices.jl package. For full usage, see the official guide at https://ap6yc.github.io/ClusterValidityIndices.jl/dev/man/guide/.\n\nBasic Usage\n\nInstall and import the package in a script with\n\nusing Pkg\nPkg.add(\"ClusterValidityIndices\")\nusing ClusterValidityIndices\n\nthen create a CVI object with an empty argument constructor\n\nmy_cvi = DB()\n\nand get the criterion values with get_cvi! (batch) or get_icvi! (incremental)\n\n# Load some features and labels from a clustering process\nfeatures, labels = get_some_clustering_data()\n\n# Batch criterion value\ncriterion_value = get_cvi!(my_cvi, features, labels)\n\n# Incremental criterion values\ncriterion_values = zeros(length(labels))\nfor ix in eachindex(labels)\n    criterion_values[ix] = get_icvi!(my_cvi, features[:, ix], labels[ix])\nend\n\nImports\n\nThe following names are imported by the package as dependencies:\n\nBase\nCore\nDocStringExtensions\nLinearAlgebra\n\nExports\n\nThe following names are exported and available when using the package:\n\nCH\nCVI\nDB\nGD43\nGD53\nPS\nWB\nXB\ncSIL\nevaluate!\nget_cvi!\nget_icvi!\nparam_batch!\nparam_inc!\nrCIP\nrelabel_cvi_data\nsort_cvi_data\n\n\n\n\n\n","category":"module"},{"location":"man/full-index/#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{CVI}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"Summary\n\nCompute the criterion value of the CVI.\n\nAfter computation, the resulting criterion value can be extracted from cvi.criterion_value. The criterion value is a function of the CVI/ICVI internal parameters, so at least two classes (i.e., unique labels) must be presented to the CVI in param_inc! or param_batch! before a non-zero value is returned.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI to use for computing the criterion value.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_batch!(my_cvi, data, labels)\njulia> evaluate!(my_cvi)\njulia> my_criterion_value = my_cvi.criterion_value\n\nMethod List / Definition Locations\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:166.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:196.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:198.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:196.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:147.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:173.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:191.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:214.\n\nevaluate!(cvi)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:216.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.get_cvi!-Tuple{CVI, AbstractMatrix{T} where T<:Real, AbstractVector{T} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.get_cvi!","text":"get_cvi!(cvi, data, labels)\n\n\nSummary\n\nget_cvi!(cvi::CVI, data::AbstractMatrix{T} where T<:Real, labels::AbstractVector{T} where T<:Integer) -> Any\n\n\nCompute and return the criterion value in batch mode.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI providing the criterion value.\ndata::RealMatrix: a matrix of data, columns as samples and rows as features, used in the external clustering process.\nlabels::IntegerVector: a vector of integers representing labels prescribed to the data by the external clustering algorithm.\n\nExamples\n\n# Create a new CVI object\nmy_cvi = CH()\n# Load in data from some external source\ndata = load_some_data()\n# Cluster the data into a set of labels as an integer vector\nlabels = my_cluster_algorithm(data)\n# Compute the final criterion value in batch mode\ncriterion_value = get_cvi!(cvi, data, labels)\n\nMethod List / Definition Locations\n\nget_cvi!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/common.jl:147.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.get_icvi!-Tuple{CVI, AbstractVector{T} where T<:Real, Integer}","page":"Index","title":"ClusterValidityIndices.get_icvi!","text":"get_icvi!(cvi, sample, label)\n\n\nSummary\n\nget_icvi!(cvi::CVI, sample::AbstractVector{T} where T<:Real, label::Integer) -> Any\n\n\nCompute and return the criterion value incrementally.\n\nArguments\n\ncvi::CVI: the stateful information of the ICVI providing the criterion value.\nsample::RealVector: a vector of features used in clustering the sample.\nlabel::Integer: the cluster label prescribed to the sample by the clustering algorithm.\n\nExamples\n\n# Create a new CVI object\nmy_cvi = CH()\n# Load in data from some external source\ndata = load_some_data()\n# Cluster the data into a set of labels as an integer vector\nlabels = my_cluster_algorithm(data)\n# Iteratively compute and extract the criterion value at every step\nn_samples = length(labels)\ncriterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    sample = data[:, ix]\n    label = labels[ix]\n    criterion_values[ix] = get_icvi!(my_cvi, sample, label)\nend\n\nMethod List / Definition Locations\n\nget_icvi!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/common.jl:116.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{CVI, AbstractMatrix{T} where T<:Real, AbstractVector{T} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"Summary\n\nCompute the CVI parameters in batch.\n\nThis method updates only the internal parameters of the CVI algorithm in batch. When the criterion value itself is needed, use evaluate! and extract it from cvi.criterion_value.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI algorithm.\ndata::RealMatrix: a matrix of data where rows are features and columns are samples, used in the external clustering algorithm.\nlabels::IntegerVector: a vector of labels that the external clustering algorithm prescribed to each column in data.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_batch!(my_cvi, data, labels)\n\nMethod List / Definition Locations\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:145.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:167.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:170.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:167.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:126.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:152.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:163.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:188.\n\nparam_batch!(cvi, data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:171.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{CVI, AbstractVector{T} where T<:Real, Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"Summary\n\nCompute the CVI parameters incrementally.\n\nThis method updates only internal parameters of the ICVI algorithm incrementally. When the criterion value itself is needed, use evaluate! and extract it from cvi.criterion_value.\n\nArguments\n\ncvi::CVI: the stateful information of the CVI/ICVI algorithm.\nsample::RealVector: a vector of features used in the external clustering algorithm.\nlabel::Integer: the label that the external clustering algorithm prescribed to the sample.\n\nExamples\n\njulia> my_cvi = CH()\njulia> data = load_some_data()\njulia> labels = my_cluster_algorithm(data)\njulia> param_inc!(my_cvi, data[:, 1], labels[1])\n\nMethod List / Definition Locations\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:88.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:86.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:91.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:91.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:74.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:93.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:84.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:81.\n\nparam_inc!(cvi, sample, label)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:95.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.relabel_cvi_data-Tuple{AbstractVector{T} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.relabel_cvi_data","text":"relabel_cvi_data(labels)\n\n\nSummary\n\nrelabel_cvi_data(labels::AbstractVector{T} where T<:Integer) -> Any\n\n\nrelabel_cvi_data(labels::IntegerVector)\n\nRelabels the vector to present new labels in incremental order.\n\nMethod List / Definition Locations\n\nrelabel_cvi_data(labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/utils.jl:26.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.sort_cvi_data-Tuple{AbstractMatrix{T} where T<:Real, AbstractVector{T} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.sort_cvi_data","text":"sort_cvi_data(data, labels)\n\n\nSummary\n\nsort_cvi_data(data::AbstractMatrix{T} where T<:Real, labels::AbstractVector{T} where T<:Integer) -> Tuple{Any, Any}\n\n\nsort_cvi_data(data::RealMatrix, labels::IntegerVector)\n\nSorts the CVI data by the label index, assuring that clusters are provided incrementally.\n\nMethod List / Definition Locations\n\nsort_cvi_data(data, labels)\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/utils.jl:13.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"man/full-index/#ClusterValidityIndices.CH","page":"Index","title":"ClusterValidityIndices.CH","text":"mutable struct CH <: CVI\n\nSummary\n\nThe stateful information of the Calinski-Harabasz (CH) Cluster Validity Index\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nT. Calinski and J. Harabasz, \"A dendrite method for cluster analysis,\" Communications in Statistics, vol. 3, no. 1, pp. 1-27, 1974.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Integer\nn_samples::Integer\nmu::AbstractVector{T} where T<:Real\nn::AbstractVector{T} where T<:Integer\nv::AbstractMatrix{T} where T<:Real\nCP::AbstractVector{T} where T<:Real\nSEP::AbstractVector{T} where T<:Real\nG::AbstractMatrix{T} where T<:Real\nBGSS::Float64\nWGSS::Float64\nn_clusters::Integer\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.CH-Tuple{}","page":"Index","title":"ClusterValidityIndices.CH","text":"CH()\n\n\nSummary\n\nCH() -> CH\n\n\nDefault constructor for the Calinski-Harabasz (CH) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nT. Calinski and J. Harabasz, \"A dendrite method for cluster analysis,\" Communications in Statistics, vol. 3, no. 1, pp. 1-27, 1974.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nMethod List / Definition Locations\n\nCH()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/CH.jl:61.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.CVI","page":"Index","title":"ClusterValidityIndices.CVI","text":"abstract type CVI\n\nSummary\n\nAbstract supertype for all CVI objects. All index instantiations are subtypes of CVI.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.DB","page":"Index","title":"ClusterValidityIndices.DB","text":"mutable struct DB <: CVI\n\nSummary\n\nThe stateful information of the Davies-Bouldin (DB) Cluster Validity Index.\n\nReferences\n\nD. L. Davies and D. W. Bouldin, \"A cluster separation measure,\" IEEE Transaction on Pattern Analysis and Machine Intelligence, vol. 1, no. 2, pp. 224-227, Feb. 1979.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Integer\nn_samples::Integer\nmu_data::AbstractVector{T} where T<:Real\nn::AbstractVector{T} where T<:Integer\nv::AbstractMatrix{T} where T<:Real\nCP::AbstractVector{T} where T<:Real\nS::AbstractVector{T} where T<:Real\nR::AbstractMatrix{T} where T<:Real\nG::AbstractMatrix{T} where T<:Real\nD::AbstractMatrix{T} where T<:Real\nn_clusters::Integer\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.DB-Tuple{}","page":"Index","title":"ClusterValidityIndices.DB","text":"DB()\n\n\nSummary\n\nDB() -> DB\n\n\nDefault constructor for the Davies-Bouldin (DB) Cluster Validity Index.\n\nReferences\n\nD. L. Davies and D. W. Bouldin, \"A cluster separation measure,\" IEEE Transaction on Pattern Analysis and Machine Intelligence, vol. 1, no. 2, pp. 224-227, Feb. 1979.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nMethod List / Definition Locations\n\nDB()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/DB.jl:58.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.GD43","page":"Index","title":"ClusterValidityIndices.GD43","text":"mutable struct GD43 <: CVI\n\nSummary\n\nThe stateful information of the Generalized Dunn's Index 43 (GD43) Cluster Validity Index.\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1-12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32-57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301-315, Jun. 1998.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Integer\nn_samples::Integer\nmu_data::AbstractVector{T} where T<:Real\nn::AbstractVector{T} where T<:Integer\nv::AbstractMatrix{T} where T<:Real\nCP::AbstractVector{T} where T<:Real\nG::AbstractMatrix{T} where T<:Real\nD::AbstractMatrix{T} where T<:Real\ninter::Float64\nintra::Float64\nn_clusters::Integer\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.GD43-Tuple{}","page":"Index","title":"ClusterValidityIndices.GD43","text":"GD43()\n\n\nSummary\n\nGD43() -> GD43\n\n\nDefault constructor for the Generalized Dunn's Index 43 (GD43) Cluster Validity Index.\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1-12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32-57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301-315, Jun. 1998.\n\nMethod List / Definition Locations\n\nGD43()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD43.jl:64.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.GD53","page":"Index","title":"ClusterValidityIndices.GD53","text":"mutable struct GD53 <: CVI\n\nSummary\n\nThe stateful information of the Generalized Dunn's Index 53 (GD53) Cluster Validity Index.\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1-12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32-57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301-315, Jun. 1998.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Integer\nn_samples::Integer\nmu_data::AbstractVector{T} where T<:Real\nn::AbstractVector{T} where T<:Integer\nv::AbstractMatrix{T} where T<:Real\nCP::AbstractVector{T} where T<:Real\nG::AbstractMatrix{T} where T<:Real\nD::AbstractMatrix{T} where T<:Real\ninter::Float64\nintra::Float64\nn_clusters::Integer\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.GD53-Tuple{}","page":"Index","title":"ClusterValidityIndices.GD53","text":"GD53()\n\n\nSummary\n\nGD53() -> GD53\n\n\nDefault constructor for the Generalized Dunn's Index 53 (GD53) Cluster Validity Index.\n\nReferences\n\nA. Ibrahim, J. M. Keller, and J. C. Bezdek, \"Evaluating Evolving Structure in Streaming Data With Modified Dunn's Indices,\" IEEE Transactions on Emerging Topics in Computational Intelligence, pp. 1-12, 2019.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\nJ. C. Dunn, \"A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,\" J. Cybern., vol. 3, no. 3 , pp. 32-57, 1973.\nJ. C. Bezdek and N. R. Pal, \"Some new indexes of cluster validity,\" IEEE Trans. Syst., Man, and Cybern., vol. 28, no. 3, pp. 301-315, Jun. 1998.\n\nMethod List / Definition Locations\n\nGD53()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/GD53.jl:64.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.PS","page":"Index","title":"ClusterValidityIndices.PS","text":"mutable struct PS <: CVI\n\nSummary\n\nThe stateful information of the Partition Separation (PS) Cluster Validity Index.\n\nReferences\n\nMiin-Shen Yang and Kuo-Lung Wu, \"A new validity index for fuzzy clustering,\" 10th IEEE International Conference on Fuzzy Systems. (Cat. No.01CH37297), Melbourne, Victoria, Australia, 2001, pp. 89-92, vol.1.\nE. Lughofer, \"Extensions of vector quantization for incremental clustering,\" Pattern Recognit., vol. 41, no. 3, pp. 995-1011, 2008.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Integer\nn_samples::Integer\nn::AbstractVector{T} where T<:Integer\nv::AbstractMatrix{T} where T<:Real\nD::AbstractMatrix{T} where T<:Real\nv_bar::AbstractVector{T} where T<:Real\nbeta_t::Float64\nPS_i::AbstractVector{T} where T<:Real\nn_clusters::Integer\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.PS-Tuple{}","page":"Index","title":"ClusterValidityIndices.PS","text":"PS()\n\n\nSummary\n\nPS() -> PS\n\n\nDefault constructor for the Partition Separation (PS) Cluster Validity Index.\n\nReferences\n\nMiin-Shen Yang and Kuo-Lung Wu, \"A new validity index for fuzzy clustering,\" 10th IEEE International Conference on Fuzzy Systems. (Cat. No.01CH37297), Melbourne, Victoria, Australia, 2001, pp. 89-92, vol.1.\nE. Lughofer, \"Extensions of vector quantization for incremental clustering,\" Pattern Recognit., vol. 41, no. 3, pp. 995-1011, 2008.\n\nMethod List / Definition Locations\n\nPS()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/PS.jl:51.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.WB","page":"Index","title":"ClusterValidityIndices.WB","text":"mutable struct WB <: CVI\n\nSummary\n\nThe stateful information of the WB-Index (WB) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nQ. Zhao, M. Xu, and P. Franti, \"Sum-of-Squares Based Cluster Validity Index and Significance Analysis,\" in Adaptive and Natural Computing Algorithms, M. Kolehmainen, P. Toivanen, and B. Beliczynski, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009, pp. 313-322.\nQ. Zhao and P. Franti, \"WB-index: A sum-of-squares based index for cluster validity,\" Data Knowledge Engineering, vol. 92, pp. 77-89, 2014.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Integer\nn_samples::Integer\nmu::AbstractVector{T} where T<:Real\nn::AbstractVector{T} where T<:Integer\nv::AbstractMatrix{T} where T<:Real\nCP::AbstractVector{T} where T<:Real\nSEP::AbstractVector{T} where T<:Real\nG::AbstractMatrix{T} where T<:Real\nBGSS::Float64\nWGSS::Float64\nn_clusters::Integer\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.WB-Tuple{}","page":"Index","title":"ClusterValidityIndices.WB","text":"WB()\n\n\nSummary\n\nWB() -> WB\n\n\nDefault constructor for the WB-Index (WB) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nQ. Zhao, M. Xu, and P. Franti, \"Sum-of-Squares Based Cluster Validity Index and Significance Analysis,\" in Adaptive and Natural Computing Algorithms, M. Kolehmainen, P. Toivanen, and B. Beliczynski, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009, pp. 313-322.\nQ. Zhao and P. Franti, \"WB-index: A sum-of-squares based index for cluster validity,\" Data Knowledge Engineering, vol. 92, pp. 77-89, 2014.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nMethod List / Definition Locations\n\nWB()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/WB.jl:66.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.XB","page":"Index","title":"ClusterValidityIndices.XB","text":"mutable struct XB <: CVI\n\nSummary\n\nThe stateful information of the Xie-Beni (XB) Cluster Validity Index.\n\nReferences\n\nX. L. Xie and G. Beni, \"A Validity Measure for Fuzzy Clustering,\" IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 13, no. 8, pp. 841-847, 1991.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Integer\nn_samples::Integer\nmu_data::AbstractVector{T} where T<:Real\nn::AbstractVector{T} where T<:Integer\nv::AbstractMatrix{T} where T<:Real\nCP::AbstractVector{T} where T<:Real\nSEP::Float64\nG::AbstractMatrix{T} where T<:Real\nD::AbstractMatrix{T} where T<:Real\nWGSS::Float64\nn_clusters::Integer\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.XB-Tuple{}","page":"Index","title":"ClusterValidityIndices.XB","text":"XB()\n\n\nSummary\n\nXB() -> XB\n\n\nDefault constructor for the Xie-Beni (XB) Cluster Validity Index.\n\nReferences\n\nX. L. Xie and G. Beni, \"A Validity Measure for Fuzzy Clustering,\" IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 13, no. 8, pp. 841-847, 1991.\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, and J. Bailey, \"Online Cluster Validity Indices for Streaming Data,\" ArXiv e-prints, 2018, arXiv:1801.02937v1 [stat.ML]. [Online].\nM. Moshtaghi, J. C. Bezdek, S. M. Erfani, C. Leckie, J. Bailey, \"Online cluster validity indices for performance monitoring of streaming data clustering,\" Int. J. Intell. Syst., pp. 1-23, 2018.\n\nMethod List / Definition Locations\n\nXB()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/XB.jl:58.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.cSIL","page":"Index","title":"ClusterValidityIndices.cSIL","text":"mutable struct cSIL <: CVI\n\nSummary\n\nThe stateful information of the Centroid-based Silhouette (cSIL) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nP. J. Rousseeuw, \"Silhouettes: A graphical aid to the interpretation and validation of cluster analysis,\" Journal of Computational and Applied Mathematics, vol. 20, pp. 53-65, 1987.\nM. Rawashdeh and A. Ralescu, \"Center-wise intra-inter silhouettes,\" in Scalable Uncertainty Management, E. Hüllermeier, S. Link, T. Fober et al., Eds. Berlin, Heidelberg: Springer, 2012, pp. 406-419.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Integer\nn_samples::Integer\nn::AbstractVector{T} where T<:Integer\nv::AbstractMatrix{T} where T<:Real\nCP::AbstractVector{T} where T<:Real\nG::AbstractMatrix{T} where T<:Real\nS::AbstractMatrix{T} where T<:Real\nsil_coefs::AbstractVector{T} where T<:Real\nn_clusters::Integer\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.cSIL-Tuple{}","page":"Index","title":"ClusterValidityIndices.cSIL","text":"cSIL()\n\n\nSummary\n\ncSIL() -> cSIL\n\n\nDefault constructor for the Centroid-based Silhouette (cSIL) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nP. J. Rousseeuw, \"Silhouettes: A graphical aid to the interpretation and validation of cluster analysis,\" Journal of Computational and Applied Mathematics, vol. 20, pp. 53-65, 1987.\nM. Rawashdeh and A. Ralescu, \"Center-wise intra-inter silhouettes,\" in Scalable Uncertainty Management, E. Hüllermeier, S. Link, T. Fober et al., Eds. Berlin, Heidelberg: Springer, 2012, pp. 406-419.\n\nMethod List / Definition Locations\n\ncSIL()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/cSIL.jl:56.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.rCIP","page":"Index","title":"ClusterValidityIndices.rCIP","text":"mutable struct rCIP <: CVI\n\nSummary\n\nThe stateful information of the (Renyi's) representative Cross Information Potential (rCIP) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nE. Gokcay and J. C. Principe, \"A new clustering evaluation function using Renyi's information potential,\" in Proc. Int. Conf. Acoust., Speech, Signal Process. (ICASSP), vol. 6. Jun. 2000, pp. 3490-3493.\nE. Gokcay and J. C. Principe, \"Information theoretic clustering,\" IEEE Trans. Pattern Anal. Mach. Intell., vol. 24, no. 2, pp. 158-171, Feb. 2002.\nD. Araújo, A. D. Neto, and A. Martins, \"Representative cross information potential clustering,\" Pattern Recognit. Lett., vol. 34, no. 16, pp. 2181-2191, Dec. 2013.\nD. Araújo, A. D. Neto, and A. Martins, \"Information-theoretic clustering: A representative and evolutionary approach,\" Expert Syst. Appl., vol. 40, no. 10, pp. 4190-4205, Aug. 2013.\nR. O. Duda, P. E. Hart, and D. G. Stork, Pattern Classification, 2nd ed. John Wiley & Sons, 2000.\n\nFields\n\nlabel_map::Dict{Int64, Int64}\ndim::Integer\nn_samples::Integer\nn::AbstractVector{T} where T<:Integer\nv::AbstractMatrix{T} where T<:Real\nsigma::Array{Float64, 3}\nconstant::Float64\nD::AbstractMatrix{T} where T<:Real\ndelta_term::AbstractMatrix{T} where T<:Real\nn_clusters::Integer\ncriterion_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.rCIP-Tuple{}","page":"Index","title":"ClusterValidityIndices.rCIP","text":"rCIP()\n\n\nSummary\n\nrCIP() -> rCIP\n\n\nDefault constructor for the (Renyi's) representative Cross Information Potential (rCIP) Cluster Validity Index.\n\nReferences\n\nL. E. Brito da Silva, N. M. Melton, and D. C. Wunsch II, \"Incremental Cluster Validity Indices for Hard Partitions: Extensions  and  Comparative Study,\" ArXiv  e-prints, Feb 2019, arXiv:1902.06711v1 [cs.LG].\nE. Gokcay and J. C. Principe, \"A new clustering evaluation function using Renyi's information potential,\" in Proc. Int. Conf. Acoust., Speech, Signal Process. (ICASSP), vol. 6. Jun. 2000, pp. 3490-3493.\nE. Gokcay and J. C. Principe, \"Information theoretic clustering,\" IEEE Trans. Pattern Anal. Mach. Intell., vol. 24, no. 2, pp. 158-171, Feb. 2002.\nD. Araújo, A. D. Neto, and A. Martins, \"Representative cross information potential clustering,\" Pattern Recognit. Lett., vol. 34, no. 16, pp. 2181-2191, Dec. 2013.\nD. Araújo, A. D. Neto, and A. Martins, \"Information-theoretic clustering: A representative and evolutionary approach,\" Expert Syst. Appl., vol. 40, no. 10, pp. 4190-4205, Aug. 2013.\nR. O. Duda, P. E. Hart, and D. G. Stork, Pattern Classification, 2nd ed. John Wiley & Sons, 2000.\n\nMethod List / Definition Locations\n\nrCIP()\n\ndefined at /home/runner/work/ClusterValidityIndices.jl/ClusterValidityIndices.jl/src/CVI/rCIP.jl:66.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"(Image: header)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ClusterValidityIndices.jl","page":"Home","title":"ClusterValidityIndices.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These pages serve as the official documentation for the ClusterValidityIndices.jl Julia package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cluster Validity Indices (CVI) tackle the problem of judging the performance of an unsupervised/clustering algorithm without the availability of truth or supervisory labels, resulting in metrics of under- or over-partitioning. Furthermore, Incremental CVIs (ICVI) are variants of these ordinarily batch algorithms that enable an online and computationally tractable method of evaluating the performance of a clustering algorithm as it clusters while being numerically equivalent to their batch counterparts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is to provide a home for the development and use of these CVIs and ICVIs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation is split into the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"getting-started/what-are-cvis.md\",\n    \"getting-started/basic-example.md\",\n    \"man/guide.md\",\n    \"../examples/index.md\",\n    \"man/contributing.md\",\n    \"man/full-index.md\",\n    \"man/dev-index.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Background provides an overview of the problem statement of CVIs and what they are theoretically, while Basic Example steps through an single example workflow.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Package Guide provides a tutorial to the full usage of the package, while Examples gives many sample workflows using a variety of CVI modules.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instructions on how to contribute to the package are found in Contributing, and docstrings for every element of the package is listed in the Index. Names internal to the package are also listed under the Developer Index.","category":"page"}]
}
