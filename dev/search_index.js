var documenterSearchIndex = {"docs":
[{"location":"man/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"This page serves as the contribution guide for the ClusterValidityIndices.jl package. From top to bottom, the ways of contributing are:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"GitHub Issues: how to raise an issue with the project.\nJulia Development: how to download and interact with the package.\nGitFlow: how to directly contribute code to the package in an organized way on GitHub.\nDevelopment Details: how the internals of the package are currently setup if you would like to directly contribute code.","category":"page"},{"location":"man/contributing/#Issues","page":"Contributing","title":"Issues","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The main point of contact is the GitHub issues page for the project. This is the easiest way to contribute to the project, as any issue you find or request you have will be addressed there by the authors of the package. Depending on the issue, the authors will collaborate with you, and after making changes they will link a pull request which addresses your concern or implements your proposed changes.","category":"page"},{"location":"man/contributing/#Julia-Development","page":"Contributing","title":"Julia Development","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"As a Julia package, development follows the usual procedure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Clone the project from GitHub\nSwitch to or create the branch that you wish work on (see GitFlow).\nStart Julia at your development folder.\nInstantiate the package (i.e., download and install the package dependencies).","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"For example, you can get the package and startup Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"git clone git@github.com:AP6YC/ClusterValidityIndices.jl.git\njulia --project=.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIn Julia, you must activate your project in the current REPL to point to the location/scope of installed packages. The above immediately activates the project when starting up Julia, but you may also separately startup the julia and activate the package with the interactive package manager via the ] syntax:julia\njulia> ]\n(@v1.6) pkg> activate .\n(ClusterValidityIndices) pkg>","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"You may run the package's unit tests after the above setup in Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> using Pkg\njulia> Pkg.instantiate()\njulia> Pkg.test()","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"or interactively though the Julia package manager with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> ]\n(ClusterValidityIndices) pkg> instantiate\n(ClusterValidityIndices) pkg> test","category":"page"},{"location":"man/contributing/#GitFlow","page":"Contributing","title":"GitFlow","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"As of verson 0.3.1, the ClusterValidityIndices.jl package follows the GitFlow git working model. The original post by Vincent Driessen outlines this methodology quite well, while Atlassian has a good tutorial as well. In summary:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Create a feature branch off of the develop branch with the name feature/<my-feature-name>.\nCommit your changes and push to this feature branch.\nWhen you are satisfied with your changes, initiate a GitHub pull request (PR) to merge the feature branch with develop.\nIf the unit tests pass, the feature branch will first be merged with develop and then be deleted.\nReleases will be periodically initiated from the develop branch and versioned onto the master branch.\nImmediate bug fixes circumvent this process through a hotfix branch off of master.","category":"page"},{"location":"man/contributing/#Development-Details","page":"Contributing","title":"Development Details","text":"","category":"section"},{"location":"man/contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"These docs are currently hosted as a static site on the GitHub pages platform. They are setup to be built and served in a separate branch gh-pages from the master/development branch of the project.","category":"page"},{"location":"man/contributing/#Package-Structure","page":"Contributing","title":"Package Structure","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The ClusterValidityIndices.jl package has the following file structure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"ClusterValidityIndices.jl\n├── .github/workflows       // GitHub: workflows for testing and documentation.\n├── data                    // Data: CI and example data location.\n├── docs                    // Docs: GitHub pages documentation files.\n├── examples                // Source: Example scripts for CVI usage.\n├── paper                   // Docs: JOSS paper and bib files.\n├── results                 // Data: Destination for example-generated files.\n├── src                     // Source: scripts and common helper functions.\n│   └─── CVI                //      All CVI and ICVI definitions\n├── test                    // Test: unit, integration, and environment tests.\n├── .gitignore              // Git: .gitignore for the whole project.\n├── LICENSE                 // Doc: the license to the project.\n├── Manifest.toml           // Julia: the explicit package versions used.\n├── Project.toml            // Julia: the Pkg.jl dependencies of the project.\n└── README.md               // Doc: this document.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"All CVIs are implemented in separate files in the src/CVI/ directory, and they are imported to src/ClusterValidityIndices.jl through imports in src/CVI/CVI.jl.","category":"page"},{"location":"man/contributing/#CVI-Module-Workflow","page":"Contributing","title":"CVI Module Workflow","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"To write a CVI for this project, it will require the following:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"A struct subtyped from CVI that implements the internal parameters in addition to a Float named criterion_value and a LabelMap.\nA Default constructor that initializes values to zeros and arrays to empties (see existing CVI files such as DB.jl for examples).\nAn incremental parameter update method param_inc!(cvi::NEW_CVI, sample::RealVector, label::Integer) where NEW_CVI is the name of the new CVI.\nA batch parameter update method param_batch!(cvi::NEW_CVI, data::RealMatrix, labels::IntegerVector).\nA criterion value evaluation method evaluate(cvi::NEW_CVI) that updates the internal criterion value.","category":"page"},{"location":"man/contributing/#Authors","page":"Contributing","title":"Authors","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"If you simply have suggestions for improvement, Sasha Petrenko (<sap625@mst.edu>) is the current developer and maintainer of the ClusterValidityIndices.jl package, so please feel free to reach out with thoughts and questions.","category":"page"},{"location":"man/full-index/#main-index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [ClusterValidityIndices]","category":"page"},{"location":"man/full-index/#ClusterValidityIndices.CH","page":"Index","title":"ClusterValidityIndices.CH","text":"CH\n\nThe stateful information of the Calinski-Harabasz (CH) CVI.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.CH-Tuple{}","page":"Index","title":"ClusterValidityIndices.CH","text":"CH()\n\nDefault constructor for the Calinski-Harabasz (CH) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.DB","page":"Index","title":"ClusterValidityIndices.DB","text":"DB\n\nThe stateful information of the Davies-Bouldin (DB) CVI.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.DB-Tuple{}","page":"Index","title":"ClusterValidityIndices.DB","text":"DB()\n\nDefault constructor for the Davies-Bouldin (DB) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.GD43","page":"Index","title":"ClusterValidityIndices.GD43","text":"GD43\n\nThe stateful information of the Generalized Dunn's Index 43 (GD43) CVI.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.GD43-Tuple{}","page":"Index","title":"ClusterValidityIndices.GD43","text":"GD43()\n\nDefault constructor for the Generalized Dunn's Index 43 (GD43) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.GD53","page":"Index","title":"ClusterValidityIndices.GD53","text":"GD53\n\nThe stateful information of the Generalized Dunn's Index 53 (GD53) CVI.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.GD53-Tuple{}","page":"Index","title":"ClusterValidityIndices.GD53","text":"GD53()\n\nDefault constructor for the Generalized Dunn's Index 53 (GD53) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.PS","page":"Index","title":"ClusterValidityIndices.PS","text":"PS\n\nThe stateful information of the Partition Separation (PS) CVI.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.PS-Tuple{}","page":"Index","title":"ClusterValidityIndices.PS","text":"PS()\n\nDefault constructor for the Partition Separation (PS) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.WB","page":"Index","title":"ClusterValidityIndices.WB","text":"WB\n\nThe stateful information of the WB-Index (WB) CVI.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.WB-Tuple{}","page":"Index","title":"ClusterValidityIndices.WB","text":"WB()\n\nDefault constructor for the WB-Index (WB) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.XB","page":"Index","title":"ClusterValidityIndices.XB","text":"XB\n\nThe stateful information of the Xie-Beni (XB) CVI.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.XB-Tuple{}","page":"Index","title":"ClusterValidityIndices.XB","text":"XB()\n\nDefault constructor for the Xie-Beni (XB) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.cSIL","page":"Index","title":"ClusterValidityIndices.cSIL","text":"cSIL\n\nThe stateful information of the Centroid-based Silhouette (cSIL) CVI.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.cSIL-Tuple{}","page":"Index","title":"ClusterValidityIndices.cSIL","text":"cSIL()\n\nDefault constructor for the Centroid-based Silhouette (cSIL) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.rCIP","page":"Index","title":"ClusterValidityIndices.rCIP","text":"rCIP\n\nThe stateful information of the (Renyi's) representative Cross Information Potential (rCIP) CVI.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#ClusterValidityIndices.rCIP-Tuple{}","page":"Index","title":"ClusterValidityIndices.rCIP","text":"rCIP()\n\nDefault constructor for the (Renyi's) representative Cross Information Potential (rCIP) Cluster Validity Index.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{CH}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::CH)\n\nCompute the criterion value of the Calinski-Harabasz (CH) CVI.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{DB}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::DB)\n\nCompute the criterion value of the Davies-Bouldin (DB) CVI.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{GD43}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::GD43)\n\nCompute the criterion value of the Generalized Dunn's Index 43 (GD43) CVI.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{GD53}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::GD53)\n\nCompute the criterion value of the Generalized Dunn's Index 53 (GD53) CVI.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{PS}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::PS)\n\nCompute the criterion value of the Partition Separation (PS) CVI.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{WB}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::WB)\n\nCompute the criterion value of the WB-Index (WB) CVI.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{XB}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::XB)\n\nCompute the criterion value of the Xie-Beni (XB) CVI.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{cSIL}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::cSIL)\n\nCompute the criterion value of the Centroid-based Silhouette (cSIL) CVI.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.evaluate!-Tuple{rCIP}","page":"Index","title":"ClusterValidityIndices.evaluate!","text":"evaluate!(cvi::rCIP)\n\nCompute the criterion value of the (Renyi's) representative Cross Information Potential (rCIP) CVI.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.get_cvi!-Tuple{CVI,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.get_cvi!","text":"get_cvi!(cvi::CVI, x::RealMatrix, y::IntegerVector)\n\nPorcelain: update compute the criterion value in batch and return it.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.get_icvi!-Tuple{CVI,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.get_icvi!","text":"get_icvi!(cvi::CVI, x::RealVector, y::Integer)\n\nPorcelain: update and compute the criterion value incrementally and return it.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.get_internal_label!-Tuple{Dict{Int64,Int64},Int64}","page":"Index","title":"ClusterValidityIndices.get_internal_label!","text":"get_internal_label!(label_map::LabelMap, label::Int)\n\nGet the internal label and update the label map if the label is new.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{CH,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::CH, data::RealMatrix, labels::IntegerVector)\n\nCompute the Calinski-Harabasz (CH) CVI in batch.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{DB,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::DB, data::RealMatrix, labels::IntegerVector)\n\nCompute the Davies-Bouldin (DB) CVI in batch.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{GD43,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::GD43, data::RealMatrix, labels::IntegerVector)\n\nCompute the Generalized Dunn's Index 43 (GD43) CVI in batch.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{GD53,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::GD53, data::RealMatrix, labels::IntegerVector)\n\nCompute the Generalized Dunn's Index 53 (GD53) CVI in batch.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{PS,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::PS, data::RealMatrix, labels::IntegerVector)\n\nCompute the Partition Separation (PS) CVI in batch.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{WB,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::WB, data::RealMatrix, labels::IntegerVector)\n\nCompute the WB-Index (WB) CVI in batch.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{XB,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::XB, data::RealMatrix, labels::IntegerVector)\n\nCompute the Xie-Beni (XB) CVI in batch.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{cSIL,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::cSIL, data::RealMatrix, labels::IntegerVector)\n\nCompute the Centroid-based Silhouette (cSIL) CVI in batch.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_batch!-Tuple{rCIP,AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.param_batch!","text":"param_batch!(cvi::rCIP, data::RealMatrix, labels::IntegerVector)\n\nCompute the (Renyi's) representative Cross Information Potential (rCIP) CVI in batch.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{CH,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::CH, sample::RealVector, label::Integer)\n\nCompute the Calinski-Harabasz (CH) CVI incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{DB,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::DB, sample::RealVector, label::Integer)\n\nCompute the Davies-Bouldin (DB) CVI incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{GD43,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::GD43, sample::RealVector, label::Integer)\n\nCompute the Generalized Dunn's Index 43 (GD43) CVI incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{GD53,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::GD53, sample::RealVector, label::Integer)\n\nCompute the Generalized Dunn's Index 53 (GD53) CVI incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{PS,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::PS, sample::RealVector, label::Integer)\n\nCompute the Partition Separation (PS) CVI incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{WB,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::WB, sample::RealVector, label::Integer)\n\nCompute the WB-Index (WB) CVI incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{XB,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::XB, sample::RealVector, label::Integer)\n\nCompute the Xie-Beni (XB) CVI incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{cSIL,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::cSIL, sample::RealVector, label::Integer)\n\nCompute the Centroid-based Silhouette (cSIL) CVI incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.param_inc!-Tuple{rCIP,AbstractArray{T,1} where T<:Real,Integer}","page":"Index","title":"ClusterValidityIndices.param_inc!","text":"param_inc!(cvi::rCIP, sample::RealVector, label::Integer)\n\nCompute the (Renyi's) representative Cross Information Potential (rCIP) CVI incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.relabel_cvi_data-Tuple{AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.relabel_cvi_data","text":"relabel_cvi_data(labels::IntegerVector)\n\nRelabels the vector to present new labels in incremental order.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{CH,Array{T,1}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::CH, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{DB,Array{T,1}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::DB, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{GD43,Array{T,1}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::GD43, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{GD53,Array{T,1}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::GD53, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{PS,Array{T,1}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::PS, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{WB,Array{T,1}}} where T<:Real","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::WB, sample::Vector{T}) where {T<:Real}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{XB,Array{T,1}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::XB, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{cSIL,Array{T,1}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::cSIL, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.setup!-Union{Tuple{T}, Tuple{rCIP,Array{T,1}}} where T<:Union{Float32, Float64}","page":"Index","title":"ClusterValidityIndices.setup!","text":"setup!(cvi::rCIP, sample::Vector{T}) where {T<:RealFP}\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#ClusterValidityIndices.sort_cvi_data-Tuple{AbstractArray{T,2} where T<:Real,AbstractArray{T,1} where T<:Integer}","page":"Index","title":"ClusterValidityIndices.sort_cvi_data","text":"sort_cvi_data(data::RealMatrix, labels::IntegerVector)\n\nSorts the CVI data by the label index, assuring that clusters are provided incrementally.\n\n\n\n\n\n","category":"method"},{"location":"man/guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"man/guide/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI package can be installed using the Julia package manager. From the Julia REPL, type ']' to enter the Pkg REPL mode and run","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"pkg> add CVI","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Alternatively, it can be added to your environment in a script with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"using Pkg\nPkg.add(\"CVI\")","category":"page"},{"location":"man/guide/#Quickstart","page":"Guide","title":"Quickstart","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"This section provides a quick overview of how to use the project. For more detailed code usage, please see Usage.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"This project has several example scripts to demonstrate the functionality of CVIs in the ClusterValidityIndices.jl package. In ICVI-Examples/src/examples/, the scripts db.jl, ps.jl, and xb.jl demonstrate usage of the Davies-Boudin (DB), Partition Separation (PS), and Xie-Beni (XB) metrics, respectively.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nEach of these scripts must be run at the top level of the project to correctly point to the datasets. For example, they can be run in the shell withjulia src/examples/db.jlor in a Julia REPL session withinclude(\"src/examples/db.jl\")","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Three preprocessed datasets are provided under data/ to demonstrate the correct partitioning, over partitioning, and under partitioning of samples by a clustering algorithm to illustrate how the CVIs behave in each case. The data consists of 2000 samples of 2-element features with the clustering label appended in the third column. You can change which dataset is used in each script above.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Lastly, there is a large experiment script src/examples/combined.jl that runs every CVI with all three datasets. The common code for all scripts and tests is contained under test/utils.jl, while the experiment subroutines referenced in these scripts are under src/experiments.jl, so feel free to modify them to further explore the behavior and usage of these CVIs.","category":"page"},{"location":"man/guide/#Usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The usage of these CVIs requires an understanding of:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Data assumptions of the CVIs.\nHow to instantiate the CVIs.\nIncremental vs. batch evaluation.\nUpdating internal CVI parameters.\nComputing and extracting the criterion values.\nPorcelain functions that are available to simplify operation.","category":"page"},{"location":"man/guide/#data","page":"Guide","title":"Data","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Because Julia is programmed in a column-major fashion, all CVIs make the assumption that the first dimension (columns) contains features, while the second dimension (rows) contains samples. This is more important for batch operation, as incremental operation accepts 1-D sample of features at each time step by definition.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example,","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Load data from somewhere\ndata = load_data()\n# The data shape is dimsion x samples\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nAs of ClusterValidityIndices.jl v0.1.3, all the CVIs assume that the labels are presented sequentially initially, starting with index 1 (e.g., 1, 1, 2, 2, 3, 2, 2, 1, 3, 4, 4 ...). You may repeat previously seen label indices, but skipping label indices (e.g., 1, 2, 4) results in undefined behavior.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"In this project, this is ameliorated with the function","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"relabel_cvi_data(labels::Array{M, 1}) where {M<:Int}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example,","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"data_file = \"path/to/data.csv\"\ndata, labels = get_cvi_data(data_file)\nlabels = relabel_cvi_data(labels)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Alternatively, you may pairwise sort the entirety of the data with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"sort_cvi_data(data::Array{N, 2}, labels::Array{M, 1}) where {N<:Real, M<:Int}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nsort_cvi_data reorders the input data as well, which will lead to different ICVI results than with relabel_cvi_data.","category":"page"},{"location":"man/guide/#instantiation","page":"Guide","title":"Instantiation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The names of each CVI are capital abbreviations of their literature names, often based upon the surname of the principal authors of the papers that introduce the metrics. All CVIs are implemented with the default constructor, such as","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cvi = DB()","category":"page"},{"location":"man/guide/#inc-batch","page":"Guide","title":"Incremental vs. Batch","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVIs in this project all contain incremental and batch implementations. When evaluated in incremental mode, they are often called ICVIs (incremental cluster validity indices). In documentation, CVI refers to both modalities (as in the literature), but in code, CVI means batch and ICVI means incremental.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The funtions that differ between the two modes are how they are updated","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nparam_inc!(...)\n# Batch\nparam_batch!(...)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"and their respective porcelain functions","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nget_icvi!(...)\n# Batch\nget_cvi!(...)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"They both compute their most recent criterion values with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"evaluate!(...)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nAny CVI can switch to be updated incrementally or in batch, as the CVI data structs are update mode agnostic.","category":"page"},{"location":"man/guide/#updating","page":"Guide","title":"Updating","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVIs in this project all contain internal parameters that must be updated. Each update function modifies the CVI, so they use the Julia nomenclature convention of appending an exclamation point to indicate as much.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"In both incremental and batch modes, the parameter update requires:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI being updates\nThe sample (or array of samples)\nThe label(s) that was/were prescribed by the clustering algorithm to the sample(s)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"More concretely, they are","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental updating\nparam_inc!(cvi::C, sample::Array{T, 1}, label::I) where {C<:CVI, T<:Real, I<:Int}\n# Batch updating\nparam_batch!(cvi::C, data::Array{T, 2}, labels::Array{I, 1}) where {C<:CVI, T<:Real, I<:Int}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Every CVI is a subtype of the abstract type CVI. For example, we may instantiate and load our data","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cvi = DB()\ndata = load_data()\nlabels = get_cluster_labels(data)\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"then update the parameters incrementally with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Iterate over all samples\nfor ix = 1:n_samples\n    sample = data[:, ix]\n    label = labels[ix]\n    param_inc!(cvi, sample, labels)\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or in batch with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"param_batch!(cvi, data, labels)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Furthermore, any CVI can alternate between being updated in incremental or batch modes, such as","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Create a new CVI\ncvi_mixed = DB()\n\n# Update on half of the data incrementally\ni_split = n_samples/2\nfor ix = 1:i_split\n    param_inc!(cvi, data[:, ix], labels[ix])\nend\n\n# Update on the other half all at once\nparam_batch!(cvi, data[:, (i_split+1):end])","category":"page"},{"location":"man/guide/#criterion-values","page":"Guide","title":"Criterion Values","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The CVI parameters are separate from the criterion values that they produce. This is partly because in batch mode computing the criterion value is only relevant at the last step, which eliminates unnecessarily computing it at every step. This is also provide granularity to the user that may only which to extract the criterion value occasionally during incremental mode.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Because the criterion values only depend on the internal CVI parameters, they are computed (and internally stored) with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"evaluate!(cvi::C) where {C<:CVI}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"To extract them, you must then simply grab the criterion value from the CVI struct with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_value = cvi.criterion_value","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, after loading the data","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cvi = DB()\ndata = load_data()\nlabels = get_cluster_labels(data)\ndim, n_samples = size(data)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"we may extract and return the criterion value at every step with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    param_inc!(cvi, data[:, ix], labels[ix])\n    evaluate!(cvi)\n    criterion_values[ix] = cvi.criterion_value\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or we may get it at the end in batch mode with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"param_batch!(cvi, data, labels)\nevaluate!(cvi)\ncriterion_value = cvi.criterion_value","category":"page"},{"location":"man/guide/#porcelain","page":"Guide","title":"Porcelain","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Taken from the git convention of calling low-level operations plumbing and high-level user-land functions porcelain, the package comes with a small set of porcelain function that do common operations all at once for the user.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, you may compute, evalute, and return the criterion value all at once with the functions","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nget_icvi!(...)\n# Batch\nget_cvi!(...)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Exactly as in the usage for updating the parameters, the functions take the cvi, sample(s), and clustered label(s) as input:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"# Incremental\nget_icvi!(cvi::C, x::Array{N, 1}, y::M) where {C<:CVI, N<:Real, M<:Int}\n# Batch\nget_cvi!(cvi::C, x::Array{N, 2}, y::Array{M, 1}) where {C<:CVI, N<:Real, M<:Int}","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"For example, after loading the data you may get the criterion value at each step with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_values = zeros(n_samples)\nfor ix = 1:n_samples\n    criterion_values[ix] = get_icvi!(cvi, data[:, ix], labels[ix])\nend","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or you may get the final criterion value in batch mode with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"criterion_value = get_cvi!(cvi, data, labels)","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"There are examples for every structure in the package within the package's examples/ folder. The code for several of these examples is provided here.","category":"page"},{"location":"man/examples/#CVI-Full-Usage-Example","page":"Examples","title":"CVI Full Usage Example","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Consider that you already have a dataset that is labeled by some clustering algorithm. This is not strictly necessary in practice, as the incremental variants of each CVI are designed to be able to run online alongside a clustering process, but we do so here for simplicity. We treat the labels here as clustering-prescribed labels rather than true supervised labels, and we treat the data as the samples that were used to cluster to those labels.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We begin by loading the module and loading the data wherever it may be:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Load the CVI/ICVI module\nusing ClusterValidityIndices\n\n# Point to the data file\ndata_path = \"data/correct_partition.csv\"\n\n# Load the data and labels\ndata, labels = get_cvi_data(data_path)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Because Julia is column-major in memory and our data samples are potentially large, we follow the Julia notation and treat the dimensions of data as [dim, n_samples].","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"note: Note\nAs of ClusterValidityIndices.jl v0.1.5, all the CVIs assume that the labels are presented sequentially initially, starting with index 1 (e.g., 1, 1, 2, 2, 3, 2, 2, 1, 3, 4, 4 ...). You may repeat previously seen label indices, but skipping label indices (e.g., 1, 2, 4) results in undefined behavior. If your data does not accomodate this,we may circumvent this by relabelling the data monotonically withlabels = relabel_cvi_data(labels)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We can get the number of samples from the length of the labels vector because each data sample corresponds to a label:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Get the number of samples for incremental iteration\nn_samples = length(labels)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We are now ready to instantiate our CVI with default parameters. Because we have incremental and batch variants, we will instantiate two CVI models, train one sequentially and one in batch, and show that their results are equivalent. We will use the Davies-Bouldin CVI/ICVI as an example here, but all CVIs in this package have the same usage.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Create two containers for the batch and incremental CVIs\ncvi_i = DB()\ncvi_b = DB()","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We will preallocate an array for the criterion values of the incremental variant so that we can populate it iteratively.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Create some storage for our criterion values\ncriterion_values_i = zeros(n_samples)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We are now ready to evaluate the ICV incrementally, which we can to in one of two ways. Most simply, we can use get_icvi! function to evaluate the ICVI and return the criterion value all at once.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Iterate across all samples\nfor ix = 1:n_samples\n    # Update the CVI parameters and extract the criterion value in one function\n    criterion_values_i[ix] = get_icvi!(cvi_i, data[:, ix], labels[ix])\nend","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"If you desire more granularity, you can separately update the internal parameters of the CVI, evaluate those internal parameters into a criterion value, and extract that criterion value from the CVI.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Iterate across all of the samples\nfor ix = ProgressBar(1:n_samples)\n    # Update the CVI internal parameters incrementally\n    param_inc!(cvi_i, data[:, ix], labels[ix])\n    # Evaluate the CVI to internally store the criterion value\n    evaluate!(cvi_i)\n    # Extract and save the criterion value at each step\n    criterion_values_i[ix] = cvi_i.criterion_value\nend","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"If we wish to do all of this in batch, we have methods that correspond to their incremental counterparts at a high level:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Update and extract the criterion value all at once\ncriterion_value_b = get_cvi!(cvi_b, data[data_path], labels[data_path])","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"and at a more granular level:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Compute the parameters in batch\nparam_batch!(cvi_b, data, labels)\n\n# Evaluate the CVI criterion value\nevaluate!(cvi_b)\n\n# Extract the criterion value\ncriterion_value = cvi_b.criterion_value","category":"page"},{"location":"#ClusterValidityIndices.jl","page":"Home","title":"ClusterValidityIndices.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These pages serve as the official documentation for the ClusterValidityIndices.jl Julia package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cluster Validity Indices (CVI) tackle the problem of judging the performance of an unsupervised/clustering algorithm without the availability of truth or supervisory labels, resulting in metrics of under- or over-partitioning. Furthermore, Incremental CVIs (ICVI) are variants of these ordinarily batch algorithms that enable an online and computationally tractable method of evaluating the performance of a clustering algorithm as it clusters while being numerically equivalent to their batch counterparts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is to provide a home for the development and use of these CVIs and ICVIs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation is split into the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/guide.md\",\n    \"man/examples.md\",\n    \"man/contributing.md\",\n    \"man/full-index.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Package Guide provides a tutorial to the full usage of the package, while Examples gives sample workflows using a variety of ART modules.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instructions on how to contribute to the package are found in Contributing, and docstrings for every element of the package is listed in the Index.","category":"page"}]
}
