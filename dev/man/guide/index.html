<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · ClusterValidityIndices.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ClusterValidityIndices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ClusterValidityIndices.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting-started/what-are-cvis/">Background</a></li><li><a class="tocitem" href="../../getting-started/basic-example/">Basic Example</a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quickstart"><span>Quickstart</span></a></li><li><a class="tocitem" href="#usage"><span>Usage</span></a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../full-index/">Index</a></li><li><a class="tocitem" href="../dev-index/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AP6YC/ClusterValidityIndices.jl/blob/develop/docs/src/man/guide.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Package-Guide"><a class="docs-heading-anchor" href="#Package-Guide">Package Guide</a><a id="Package-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Guide" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The CVI package can be installed using the Julia package manager. From the Julia REPL, type &#39;]&#39; to enter the Pkg REPL mode and run</p><pre><code class="language-julia hljs">pkg&gt; add CVI</code></pre><p>Alternatively, it can be added to your environment in a script with</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;ClusterValidityIndices&quot;)</code></pre><h2 id="Quickstart"><a class="docs-heading-anchor" href="#Quickstart">Quickstart</a><a id="Quickstart-1"></a><a class="docs-heading-anchor-permalink" href="#Quickstart" title="Permalink"></a></h2><p>This section provides a quick overview of how to use the project. For more detailed code usage, please see <a href="#usage">Usage</a>. For a variety of detailed examples that you can run yourself, please see the <a href="../../examples/#examples">Examples</a> page.</p><p>First, assume that you have a dataset of features/data and labels prescribed by some clustering algorithm:</p><pre><code class="language-julia hljs">data_file = &quot;path/to/data.csv&quot;
data, labels = get_cvi_data(data_file)</code></pre><p>All CVI objects in this package are acronymed versions of their full names, which can be found in the <a href="../full-index/#index-types">Index</a>. You can create a new CVI structure with a default constructor:</p><pre><code class="language-julia hljs"># Davies-Bouldin (DB)
my_cvi = DB()</code></pre><p>The output of CVIs are called <em>criterion values</em>, and they can be computed incrementally with <code>get_icvi</code></p><pre><code class="language-julia hljs">n_samples = length(labels)
criterion_values = zeros(n_samples)
for i = 1:n_samples
    criterion_values[i] = get_icvi(data[:, i], labels[i])
end</code></pre><p>or in batch with <code>get_cvi</code></p><pre><code class="language-julia hljs">criterion_value = get_cvi(data, labels)</code></pre><h2 id="usage"><a class="docs-heading-anchor" href="#usage">Usage</a><a id="usage-1"></a><a class="docs-heading-anchor-permalink" href="#usage" title="Permalink"></a></h2><p>The usage of these CVIs requires an understanding of:</p><ul><li><a href="#data">Data</a> assumptions of the CVIs.</li><li><a href="#instantiation">How to instantiate</a> the CVIs.</li><li><a href="#inc-batch">Incremental vs. batch</a> evaluation.</li><li><a href="#updating">Updating</a> internal CVI parameters.</li><li><a href="#criterion-values">Computing and extracting</a> the criterion values.</li><li><a href="#porcelain">Porcelain functions</a> that are available to simplify operation.</li></ul><h3 id="data"><a class="docs-heading-anchor" href="#data">Data</a><a id="data-1"></a><a class="docs-heading-anchor-permalink" href="#data" title="Permalink"></a></h3><p>Because Julia is programmed in a column-major fashion, all CVIs make the assumption that the first dimension (columns) contains features, while the second dimension (rows) contains samples. This is more important for batch operation, as incremental operation accepts 1-D sample of features at each time step by definition.</p><p>For example,</p><pre><code class="language-julia hljs"># Load data from somewhere
data = load_data()
# The data shape is dimsion x samples
dim, n_samples = size(data)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As of ClusterValidityIndices.jl v0.1.3, all the CVIs assume that the labels are presented sequentially initially, starting with index 1 (e.g., 1, 1, 2, 2, 3, 2, 2, 1, 3, 4, 4 ...). You may repeat previously seen label indices, but skipping label indices (e.g., 1, 2, 4) results in undefined behavior.</p></div></div><p>In this project, this is ameliorated with the function</p><pre><code class="language-julia hljs">relabel_cvi_data(labels::IntegerVector)</code></pre><p>For example,</p><pre><code class="language-julia hljs">data_file = &quot;path/to/data.csv&quot;
data, labels = get_cvi_data(data_file)
labels = relabel_cvi_data(labels)</code></pre><p>Alternatively, you may pairwise sort the entirety of the data with</p><pre><code class="language-julia hljs">sort_cvi_data(data::RealMatrix, labels::IntegerVector)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>sort_cvi_data</code> reorders the input data as well, which will lead to different ICVI results than with <code>relabel_cvi_data</code>.</p></div></div><h3 id="instantiation"><a class="docs-heading-anchor" href="#instantiation">Instantiation</a><a id="instantiation-1"></a><a class="docs-heading-anchor-permalink" href="#instantiation" title="Permalink"></a></h3><p>The names of each CVI are capital abbreviations of their literature names, often based upon the surname of the principal authors of the papers that introduce the metrics. All CVIs are implemented with the default constructor, such as</p><pre><code class="language-julia hljs">cvi = DB()</code></pre><h3 id="inc-batch"><a class="docs-heading-anchor" href="#inc-batch">Incremental vs. Batch</a><a id="inc-batch-1"></a><a class="docs-heading-anchor-permalink" href="#inc-batch" title="Permalink"></a></h3><p>The CVIs in this project all contain <em>incremental</em> and <em>batch</em> implementations. When evaluated in incremental mode, they are often called ICVIs (incremental cluster validity indices). In this documentation, CVI means batch and ICVI means incremental, though both are <code>CVI</code> objects.</p><p>The funtions that differ between the two modes are how they are updated:</p><pre><code class="language-julia hljs"># Incremental
param_inc!(cvi::CVI, sample::RealVector, label::Integer)
# Batch
param_batch!(cvi::CVI, data::RealMatrix, labels::IntegerVector)</code></pre><p>After updating their internal parameters, they both compute their most recent criterion values with</p><pre><code class="language-julia hljs">evaluate!(cvi::CVI)</code></pre><p>To simplify the process, both modes have their respective &quot;porcelain&quot; functions to update the internal parameters, evaluate the criterion value, and return it:</p><pre><code class="language-julia hljs"># Incremental
get_icvi!(cvi::CVI, sample::RealVector, label::Integer)
# Batch
get_cvi!(cvi::CVI, data::RealMatrix, labels::IntegerVector)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Any CVI object can be updated incrementally or in batch, as the CVIs are equivalent to their ICVI counterparts after all data is presented.</p></div></div><h3 id="updating"><a class="docs-heading-anchor" href="#updating">Updating</a><a id="updating-1"></a><a class="docs-heading-anchor-permalink" href="#updating" title="Permalink"></a></h3><p>The CVIs in this project all contain internal <em>parameters</em> that must be updated. Each update function modifies the CVI, so they use the Julia nomenclature convention of appending an exclamation point to indicate as much.</p><p>In both incremental and batch modes, the parameter update requires:</p><ul><li>The CVI being updates</li><li>The sample (or array of samples)</li><li>The label(s) that was/were prescribed by the clustering algorithm to the sample(s)</li></ul><p>More concretely, they are</p><pre><code class="language-julia hljs"># Incremental updating
param_inc!(cvi::CVI, sample::RealVector, label::Integer)
# Batch updating
param_batch!(cvi::CVI, data::RealMatrix, labels::IntegerVector)</code></pre><p>Every CVI is a subtype of the abstract type <code>CVI</code>. For example, we may instantiate and load our data</p><pre><code class="language-julia hljs">cvi = DB()
data = load_data()
labels = get_cluster_labels(data)
dim, n_samples = size(data)</code></pre><p>then update the parameters incrementally with</p><pre><code class="language-julia hljs"># Iterate over all samples
for ix = 1:n_samples
    sample = data[:, ix]
    label = labels[ix]
    param_inc!(cvi, sample, labels)
end</code></pre><p>or in batch with</p><pre><code class="language-julia hljs">param_batch!(cvi, data, labels)</code></pre><p>Furthermore, any CVI can alternate between being updated in incremental or batch modes, such as</p><pre><code class="language-julia hljs"># Create a new CVI
cvi_mixed = DB()

# Update on half of the data incrementally
i_split = n_samples/2
for ix = 1:i_split
    param_inc!(cvi, data[:, ix], labels[ix])
end

# Update on the other half all at once
param_batch!(cvi, data[:, (i_split+1):end])</code></pre><h3 id="criterion-values"><a class="docs-heading-anchor" href="#criterion-values">Criterion Values</a><a id="criterion-values-1"></a><a class="docs-heading-anchor-permalink" href="#criterion-values" title="Permalink"></a></h3><p>The CVI parameters are separate from the criterion values that they produce. This is partly because in batch mode computing the criterion value is only relevant at the last step, which eliminates unnecessarily computing it at every step. This is also provide granularity to the user that may only which to extract the criterion value occasionally during incremental mode.</p><p>Because the criterion values only depend on the internal CVI parameters, they are computed (and internally stored) with</p><pre><code class="language-julia hljs">evaluate!(cvi::C) where {C&lt;:CVI}</code></pre><p>To extract them, you must then simply grab the criterion value from the CVI struct with</p><pre><code class="language-julia hljs">criterion_value = cvi.criterion_value</code></pre><p>For example, after loading the data</p><pre><code class="language-julia hljs">cvi = DB()
data = load_data()
labels = get_cluster_labels(data)
dim, n_samples = size(data)</code></pre><p>we may extract and return the criterion value at every step with</p><pre><code class="language-julia hljs">criterion_values = zeros(n_samples)
for ix = 1:n_samples
    param_inc!(cvi, data[:, ix], labels[ix])
    evaluate!(cvi)
    criterion_values[ix] = cvi.criterion_value
end</code></pre><p>or we may get it at the end in batch mode with</p><pre><code class="language-julia hljs">param_batch!(cvi, data, labels)
evaluate!(cvi)
criterion_value = cvi.criterion_value</code></pre><h3 id="porcelain"><a class="docs-heading-anchor" href="#porcelain">Porcelain</a><a id="porcelain-1"></a><a class="docs-heading-anchor-permalink" href="#porcelain" title="Permalink"></a></h3><p>Taken from the <code>git</code> convention of calling low-level operations <em>plumbing</em> and high-level user-land functions <em>porcelain</em>, the package comes with a small set of <em>porcelain</em> function that do common operations all at once for the user.</p><p>For example, you may compute, evalute, and return the criterion value all at once with the functions</p><pre><code class="language-julia hljs"># Incremental
get_icvi!(...)
# Batch
get_cvi!(...)</code></pre><p>Exactly as in the usage for updating the parameters, the functions take the cvi, sample(s), and clustered label(s) as input:</p><pre><code class="language-julia hljs"># Incremental
get_icvi!(cvi::CVI, sample::RealVector, label::Integer)
# Batch
get_cvi!(cvi::CVI, data::RealMatrix, labels::IntegerVector)</code></pre><p>For example, after loading the data you may get the criterion value at each step with</p><pre><code class="language-julia hljs">criterion_values = zeros(n_samples)
for ix = 1:n_samples
    criterion_values[ix] = get_icvi!(cvi, data[:, ix], labels[ix])
end</code></pre><p>or you may get the final criterion value in batch mode with</p><pre><code class="language-julia hljs">criterion_value = get_cvi!(cvi, data, labels)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../getting-started/basic-example/">« Basic Example</a><a class="docs-footer-nextpage" href="../../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 7 October 2022 01:56">Friday 7 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
